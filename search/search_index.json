{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Redlock4j","text":"<p>A robust Java implementation of the Redlock distributed locking algorithm for Redis.</p>"},{"location":"#overview","title":"Overview","text":"<p>Redlock4j provides a reliable distributed locking mechanism using Redis, implementing the Redlock algorithm proposed by Redis creator Antirez. It ensures mutual exclusion across distributed systems with high availability and fault tolerance.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Pure Redlock distributed locking algorithm - entirely based on Redis definition</li> <li>Multiple Redis Drivers: Integrated supports for Jedis and Lettuce, extensible to other drivers</li> <li>Lightweight - Minimum implementation, no extra scope outside locking</li> <li>Multi-interface API - Supports standard Lock, as well as async and reactive APIs</li> <li>Advanced Locking: Fair, multi &amp; read-write locks, semaphores, and countdown latches</li> <li>Lock Extension: Extend lock validity time without releasing and re-acquiring</li> <li>Atomic CAS/CAD: Auto-detects native Redis 8.4+ CAS/CAD commands when available</li> <li>Java 8+ - Compatible with Java 8 and higher</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>// Create a Redlock instance\nRedlock redlock = new Redlock(jedisPool1, jedisPool2, jedisPool3);\n\n// Acquire a lock\nLock lock = redlock.lock(\"my-resource\", 10000);\n\nif (lock != null) {\n    try {\n        // Critical section - your protected code here\n        performCriticalOperation();\n    } finally {\n        // Always unlock in a finally block\n        redlock.unlock(lock);\n    }\n} else {\n    // Failed to acquire lock\n    handleLockFailure();\n}\n</code></pre>"},{"location":"#why-redlock4j","title":"Why Redlock4j?","text":""},{"location":"#distributed-lock-guarantees","title":"Distributed Lock Guarantees","text":"<p>Redlock4j provides the following safety and liveness guarantees:</p> <ol> <li>Mutual Exclusion - At most one client can hold a lock at any given time</li> <li>Deadlock Free - Eventually it's always possible to acquire a lock, even if the client that locked a resource crashes</li> <li>Fault Tolerance - As long as the majority of Redis nodes are up, clients can acquire and release locks</li> </ol>"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>Distributed Task Scheduling - Ensure only one instance processes a scheduled task</li> <li>Resource Access Control - Coordinate access to shared resources across services</li> <li>Leader Election - Implement leader election in distributed systems</li> <li>Rate Limiting - Implement distributed rate limiting</li> <li>Cache Invalidation - Coordinate cache updates across multiple instances</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Check out the Installation Guide to add Redlock4j to your project, or jump straight to the Quick Start to see it in action.</p>"},{"location":"#license","title":"License","text":"<p>Redlock4j is released under the MIT License.</p>"},{"location":"comparison/","title":"Redlock4j vs Redisson","text":"<p>Comparison between Redlock4j and Redisson for distributed locking.</p>"},{"location":"comparison/#quick-comparison","title":"Quick Comparison","text":"Feature Redlock4j Redisson Algorithm Pure Redlock Single instance / Master-Slave API Standard Java Lock Custom RLock Dependencies Minimal Netty + many others Size ~10 core classes 50+ data structures Focus Distributed locking Full Redis framework Learning Curve Low Medium-High Redis Clients Jedis or Lettuce Built-in Netty client"},{"location":"comparison/#architecture","title":"Architecture","text":""},{"location":"comparison/#redlock4j","title":"Redlock4j","text":"<ul> <li>Pure Redlock Implementation: Follows the official Redlock algorithm</li> <li>Quorum-Based: Requires majority (N/2+1) of Redis nodes</li> <li>Multi-Master: Works with independent Redis instances</li> <li>Fault Tolerant: Survives minority node failures</li> </ul>"},{"location":"comparison/#redisson","title":"Redisson","text":"<ul> <li>Single Instance: Standard RLock uses single Redis</li> <li>Master-Slave: RedissonRedLock available but not default</li> <li>Full Framework: Comprehensive Redis client library</li> <li>Feature Rich: Many data structures beyond locks</li> </ul>"},{"location":"comparison/#api-comparison","title":"API Comparison","text":""},{"location":"comparison/#redlock4j-standard-java-lock","title":"Redlock4j - Standard Java Lock","text":"<pre><code>Lock lock = manager.createLock(\"resource\");\nlock.lock();\ntry {\n    // Critical section\n} finally {\n    lock.unlock();\n}\n</code></pre> <p>Advantages: - Familiar Java API - Drop-in replacement for <code>java.util.concurrent.locks.Lock</code> - No learning curve</p>"},{"location":"comparison/#redisson-custom-rlock","title":"Redisson - Custom RLock","text":"<pre><code>RLock lock = redisson.getLock(\"resource\");\nlock.lock();\ntry {\n    // Critical section\n} finally {\n    lock.unlock();\n}\n</code></pre> <p>Differences: - Custom <code>RLock</code> interface - Additional methods (tryLock with lease time, etc.) - Redisson-specific API</p>"},{"location":"comparison/#safety-guarantees","title":"Safety Guarantees","text":""},{"location":"comparison/#redlock4j_1","title":"Redlock4j","text":"<p>\u2705 True Distributed Lock - Requires majority of nodes to acquire lock - Survives minority node failures - Clock drift compensation - No single point of failure</p>"},{"location":"comparison/#redisson-standard-rlock","title":"Redisson Standard RLock","text":"<p>\u26a0\ufe0f Single Instance Lock - Uses single Redis instance - Master failure = lock unavailable - Replication lag can cause issues - Single point of failure</p>"},{"location":"comparison/#redisson-redissonredlock","title":"Redisson RedissonRedLock","text":"<p>\u2705 Redlock Implementation - Similar to Redlock4j - Requires explicit use of <code>RedissonRedLock</code> - Not the default locking mechanism</p>"},{"location":"comparison/#dependencies","title":"Dependencies","text":""},{"location":"comparison/#redlock4j_2","title":"Redlock4j","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.codarama&lt;/groupId&gt;\n    &lt;artifactId&gt;redlock4j&lt;/artifactId&gt;\n    &lt;version&gt;1.1.0&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!-- Plus your choice of Jedis or Lettuce --&gt;\n</code></pre> <p>Size: ~50KB Dependencies: Minimal (SLF4J + Redis client)</p>"},{"location":"comparison/#redisson_1","title":"Redisson","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.redisson&lt;/groupId&gt;\n    &lt;artifactId&gt;redisson&lt;/artifactId&gt;\n    &lt;version&gt;3.x.x&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Size: Several MB Dependencies: Netty, Jackson, many others</p>"},{"location":"comparison/#use-cases","title":"Use Cases","text":""},{"location":"comparison/#choose-redlock4j-when","title":"Choose Redlock4j When:","text":"<ul> <li>\u2705 You need true distributed locking</li> <li>\u2705 You want minimal dependencies</li> <li>\u2705 You prefer standard Java APIs</li> <li>\u2705 You need multi-master setup</li> <li>\u2705 You want lightweight library</li> </ul>"},{"location":"comparison/#choose-redisson-when","title":"Choose Redisson When:","text":"<ul> <li>\u2705 You need many Redis data structures</li> <li>\u2705 You want all-in-one framework</li> <li>\u2705 You need reactive/async APIs</li> <li>\u2705 You use Redis Cluster/Sentinel</li> <li>\u2705 Single instance locking is sufficient</li> </ul>"},{"location":"comparison/#performance","title":"Performance","text":""},{"location":"comparison/#redlock4j_3","title":"Redlock4j","text":"<ul> <li>Latency: Higher (requires majority quorum)</li> <li>Throughput: Moderate (multiple Redis calls)</li> <li>Network: More network calls</li> <li>Best For: Safety over speed</li> </ul>"},{"location":"comparison/#redisson_2","title":"Redisson","text":"<ul> <li>Latency: Lower (single instance)</li> <li>Throughput: Higher (single call)</li> <li>Network: Fewer network calls</li> <li>Best For: Speed over safety</li> </ul>"},{"location":"comparison/#migration","title":"Migration","text":""},{"location":"comparison/#from-redisson-to-redlock4j","title":"From Redisson to Redlock4j","text":"<pre><code>// Before (Redisson)\nRLock lock = redisson.getLock(\"resource\");\nlock.lock();\ntry {\n    // work\n} finally {\n    lock.unlock();\n}\n\n// After (Redlock4j)\nLock lock = manager.createLock(\"resource\");\nlock.lock();\ntry {\n    // work\n} finally {\n    lock.unlock();\n}\n</code></pre>"},{"location":"comparison/#from-redlock4j-to-redisson","title":"From Redlock4j to Redisson","text":"<pre><code>// Before (Redlock4j)\nLock lock = manager.createLock(\"resource\");\nlock.lock();\n\n// After (Redisson RedissonRedLock)\nRLock lock1 = redisson1.getLock(\"resource\");\nRLock lock2 = redisson2.getLock(\"resource\");\nRLock lock3 = redisson3.getLock(\"resource\");\nRedissonRedLock lock = new RedissonRedLock(lock1, lock2, lock3);\nlock.lock();\n</code></pre>"},{"location":"comparison/#conclusion","title":"Conclusion","text":"<p>Redlock4j is ideal for applications that: - Need true distributed locking guarantees - Want minimal dependencies - Prefer standard Java APIs - Value simplicity and focus</p> <p>Redisson is ideal for applications that: - Need comprehensive Redis functionality - Want a full-featured framework - Require reactive/async support - Can accept single-instance locking</p> <p>For complete comparison, see COMPARISON.md in the repository.</p>"},{"location":"api/configuration/","title":"Configuration API Reference","text":"<p>Detailed reference for configuring Redlock4j.</p>"},{"location":"api/configuration/#redlockconfiguration","title":"RedlockConfiguration","text":"<p>Main configuration class for Redlock behavior.</p>"},{"location":"api/configuration/#builder-pattern","title":"Builder Pattern","text":"<pre><code>RedlockConfiguration config = RedlockConfiguration.builder()\n    .retryCount(3)\n    .retryDelay(200)\n    .clockDriftFactor(0.01)\n    .build();\n</code></pre>"},{"location":"api/configuration/#configuration-properties","title":"Configuration Properties","text":""},{"location":"api/configuration/#retrycount","title":"retryCount","text":"<p>Number of times to retry lock acquisition if it fails.</p> <p>Type: <code>int</code> Default: <code>3</code> Range: <code>0</code> to <code>Integer.MAX_VALUE</code></p> <pre><code>RedlockConfiguration config = RedlockConfiguration.builder()\n    .retryCount(5)  // Retry up to 5 times\n    .build();\n</code></pre> <p>Use Cases: - High contention: Increase retry count - Low contention: Decrease for faster failure - Time-sensitive: Set to 0 for no retries</p>"},{"location":"api/configuration/#retrydelay","title":"retryDelay","text":"<p>Delay in milliseconds between retry attempts.</p> <p>Type: <code>int</code> Default: <code>200</code> Range: <code>0</code> to <code>Integer.MAX_VALUE</code></p> <pre><code>RedlockConfiguration config = RedlockConfiguration.builder()\n    .retryDelay(100)  // Wait 100ms between retries\n    .build();\n</code></pre> <p>Use Cases: - High contention: Increase delay to reduce Redis load - Low latency required: Decrease delay - Exponential backoff: Implement custom retry logic</p>"},{"location":"api/configuration/#clockdriftfactor","title":"clockDriftFactor","text":"<p>Factor to compensate for clock drift between Redis instances.</p> <p>Type: <code>double</code> Default: <code>0.01</code> (1%) Range: <code>0.0</code> to <code>1.0</code></p> <pre><code>RedlockConfiguration config = RedlockConfiguration.builder()\n    .clockDriftFactor(0.02)  // 2% clock drift\n    .build();\n</code></pre> <p>Formula: <pre><code>validity_time = ttl - elapsed_time - (ttl * clockDriftFactor)\n</code></pre></p> <p>Use Cases: - Synchronized clocks: Use smaller factor (0.001) - Unsynchronized clocks: Use larger factor (0.05) - Default: 0.01 is safe for most cases</p>"},{"location":"api/configuration/#complete-configuration-example","title":"Complete Configuration Example","text":"<pre><code>import org.codarama.redlock4j.Redlock;\nimport org.codarama.redlock4j.RedlockConfiguration;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\npublic class ConfigurationExample {\n    public static Redlock createRedlock() {\n        // Configure Jedis pools\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        poolConfig.setMaxTotal(128);\n        poolConfig.setMaxIdle(64);\n        poolConfig.setMinIdle(16);\n        poolConfig.setTestOnBorrow(true);\n        poolConfig.setTestWhileIdle(true);\n\n        JedisPool pool1 = new JedisPool(poolConfig, \"redis1.example.com\", 6379);\n        JedisPool pool2 = new JedisPool(poolConfig, \"redis2.example.com\", 6379);\n        JedisPool pool3 = new JedisPool(poolConfig, \"redis3.example.com\", 6379);\n\n        // Configure Redlock\n        RedlockConfiguration config = RedlockConfiguration.builder()\n            .retryCount(5)\n            .retryDelay(200)\n            .clockDriftFactor(0.01)\n            .build();\n\n        return new Redlock(config, pool1, pool2, pool3);\n    }\n}\n</code></pre>"},{"location":"api/configuration/#environment-specific-configurations","title":"Environment-Specific Configurations","text":""},{"location":"api/configuration/#development","title":"Development","text":"<pre><code>// Minimal configuration for development\nRedlockConfiguration devConfig = RedlockConfiguration.builder()\n    .retryCount(1)\n    .retryDelay(100)\n    .build();\n\n// Single Redis instance is acceptable for dev\nJedisPool devPool = new JedisPool(\"localhost\", 6379);\nRedlock devRedlock = new Redlock(devConfig, devPool);\n</code></pre>"},{"location":"api/configuration/#staging","title":"Staging","text":"<pre><code>// Moderate configuration for staging\nRedlockConfiguration stagingConfig = RedlockConfiguration.builder()\n    .retryCount(3)\n    .retryDelay(200)\n    .clockDriftFactor(0.01)\n    .build();\n\n// 3 Redis instances\nRedlock stagingRedlock = new Redlock(\n    stagingConfig,\n    new JedisPool(\"redis1.staging\", 6379),\n    new JedisPool(\"redis2.staging\", 6379),\n    new JedisPool(\"redis3.staging\", 6379)\n);\n</code></pre>"},{"location":"api/configuration/#production","title":"Production","text":"<pre><code>// Robust configuration for production\nRedlockConfiguration prodConfig = RedlockConfiguration.builder()\n    .retryCount(5)\n    .retryDelay(200)\n    .clockDriftFactor(0.01)\n    .build();\n\n// 5 Redis instances for high availability\nRedlock prodRedlock = new Redlock(\n    prodConfig,\n    new JedisPool(poolConfig, \"redis1.prod\", 6379),\n    new JedisPool(poolConfig, \"redis2.prod\", 6379),\n    new JedisPool(poolConfig, \"redis3.prod\", 6379),\n    new JedisPool(poolConfig, \"redis4.prod\", 6379),\n    new JedisPool(poolConfig, \"redis5.prod\", 6379)\n);\n</code></pre>"},{"location":"api/configuration/#redis-connection-configuration","title":"Redis Connection Configuration","text":""},{"location":"api/configuration/#jedis-pool-configuration","title":"Jedis Pool Configuration","text":"<p>Configure Jedis connection pools for optimal performance:</p> <pre><code>import redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\nJedisPoolConfig poolConfig = new JedisPoolConfig();\npoolConfig.setMaxTotal(128);\npoolConfig.setMaxIdle(128);\npoolConfig.setMinIdle(16);\npoolConfig.setTestOnBorrow(true);\npoolConfig.setTestOnReturn(true);\npoolConfig.setTestWhileIdle(true);\n\nJedisPool pool = new JedisPool(poolConfig, \"localhost\", 6379);\n</code></pre>"},{"location":"api/configuration/#lettuce-client-configuration","title":"Lettuce Client Configuration","text":"<p>Configure Lettuce clients:</p> <pre><code>import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.ClientOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport java.time.Duration;\n\nRedisURI redisUri = RedisURI.builder()\n    .withHost(\"localhost\")\n    .withPort(6379)\n    .withTimeout(Duration.ofSeconds(5))\n    .build();\n\nClientOptions options = ClientOptions.builder()\n    .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(5)))\n    .build();\n\nRedisClient client = RedisClient.create(redisUri);\nclient.setOptions(options);\n</code></pre>"},{"location":"api/configuration/#configuration-best-practices","title":"Configuration Best Practices","text":""},{"location":"api/configuration/#lock-ttl","title":"Lock TTL","text":"<p>Choose an appropriate TTL based on your use case:</p> <ul> <li>Short operations (&lt; 1 second): Use 5-10 second TTL</li> <li>Medium operations (1-10 seconds): Use 30-60 second TTL</li> <li>Long operations (&gt; 10 seconds): Consider if distributed locking is the right solution</li> </ul> <p>TTL Too Short</p> <p>If your TTL is too short, the lock might expire before your operation completes, allowing another client to acquire the lock.</p>"},{"location":"api/configuration/#retry-strategy","title":"Retry Strategy","text":"<ul> <li>High contention: Increase retry count and delay</li> <li>Low contention: Reduce retry count for faster failure</li> <li>Time-sensitive: Reduce retry count to fail fast</li> </ul> <pre><code>// High contention scenario\nRedlockConfiguration highContention = RedlockConfiguration.builder()\n    .retryCount(10)      // More retries\n    .retryDelay(500)     // Longer delay\n    .build();\n\n// Low latency requirement\nRedlockConfiguration lowLatency = RedlockConfiguration.builder()\n    .retryCount(1)       // Fail fast\n    .retryDelay(50)      // Short delay\n    .build();\n</code></pre>"},{"location":"api/configuration/#number-of-redis-instances","title":"Number of Redis Instances","text":"<ul> <li>Minimum: 3 instances for fault tolerance</li> <li>Recommended: 5 instances for high availability</li> <li>Odd number: Always use an odd number to ensure clear majority</li> </ul>"},{"location":"api/configuration/#clock-drift","title":"Clock Drift","text":"<pre><code>// Well-synchronized clocks (NTP)\nRedlockConfiguration syncedClocks = RedlockConfiguration.builder()\n    .clockDriftFactor(0.001)  // 0.1% drift\n    .build();\n\n// Unsynchronized clocks\nRedlockConfiguration unsyncedClocks = RedlockConfiguration.builder()\n    .clockDriftFactor(0.05)   // 5% drift\n    .build();\n</code></pre>"},{"location":"api/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Core API - Core API reference</li> <li>Basic Usage - Learn common usage patterns</li> </ul>"},{"location":"api/core/","title":"Core API Reference","text":"<p>This page documents the core API of Redlock4j.</p>"},{"location":"api/core/#redlock-class","title":"Redlock Class","text":"<p>The main class for creating and managing distributed locks.</p>"},{"location":"api/core/#constructor","title":"Constructor","text":"<pre><code>public Redlock(JedisPool... pools)\npublic Redlock(RedisClient... clients)\npublic Redlock(RedlockConfiguration config, JedisPool... pools)\npublic Redlock(RedlockConfiguration config, RedisClient... clients)\n</code></pre> <p>Parameters: - <code>config</code> - Configuration for Redlock behavior (optional) - <code>pools</code> - Jedis connection pools for Redis instances - <code>clients</code> - Lettuce Redis clients</p> <p>Example: <pre><code>Redlock redlock = new Redlock(pool1, pool2, pool3);\n</code></pre></p>"},{"location":"api/core/#lock","title":"lock()","text":"<p>Acquire a lock with retries.</p> <pre><code>public Lock lock(String resource, int ttl)\npublic Lock lock(String resource, int ttl, int timeout)\npublic Lock lock(String[] resources, int ttl)\n</code></pre> <p>Parameters: - <code>resource</code> - Resource identifier to lock - <code>resources</code> - Multiple resources to lock atomically - <code>ttl</code> - Time-to-live in milliseconds - <code>timeout</code> - Maximum time to wait for lock acquisition (optional)</p> <p>Returns: - <code>Lock</code> object if successful, <code>null</code> if failed</p> <p>Example: <pre><code>Lock lock = redlock.lock(\"my-resource\", 10000);\n</code></pre></p>"},{"location":"api/core/#trylock","title":"tryLock()","text":"<p>Attempt to acquire a lock without retries.</p> <pre><code>public Lock tryLock(String resource, int ttl)\n</code></pre> <p>Parameters: - <code>resource</code> - Resource identifier to lock - <code>ttl</code> - Time-to-live in milliseconds</p> <p>Returns: - <code>Lock</code> object if successful, <code>null</code> if failed</p> <p>Example: <pre><code>Lock lock = redlock.tryLock(\"my-resource\", 10000);\n</code></pre></p>"},{"location":"api/core/#unlock","title":"unlock()","text":"<p>Release a previously acquired lock.</p> <pre><code>public void unlock(Lock lock)\n</code></pre> <p>Parameters: - <code>lock</code> - Lock object to release</p> <p>Example: <pre><code>redlock.unlock(lock);\n</code></pre></p>"},{"location":"api/core/#extend","title":"extend()","text":"<p>Extend the TTL of an existing lock.</p> <pre><code>public boolean extend(Lock lock, int additionalTtl)\n</code></pre> <p>Parameters: - <code>lock</code> - Lock to extend - <code>additionalTtl</code> - Additional time in milliseconds</p> <p>Returns: - <code>true</code> if extension successful, <code>false</code> otherwise</p> <p>Example: <pre><code>boolean extended = redlock.extend(lock, 5000);\n</code></pre></p>"},{"location":"api/core/#isvalid","title":"isValid()","text":"<p>Check if a lock is still valid.</p> <pre><code>public boolean isValid(Lock lock)\n</code></pre> <p>Parameters: - <code>lock</code> - Lock to check</p> <p>Returns: - <code>true</code> if lock is still valid, <code>false</code> otherwise</p> <p>Example: <pre><code>if (redlock.isValid(lock)) {\n    // Lock is still valid\n}\n</code></pre></p>"},{"location":"api/core/#lock-interface","title":"Lock Interface","text":"<p>Represents a distributed lock.</p>"},{"location":"api/core/#methods","title":"Methods","text":"<pre><code>public String getResource()\npublic String getValue()\npublic long getValidityTime()\n</code></pre> <p>Example: <pre><code>Lock lock = redlock.lock(\"resource\", 10000);\nString resource = lock.getResource();  // \"resource\"\nString value = lock.getValue();        // Unique lock value\nlong validity = lock.getValidityTime(); // Remaining validity in ms\n</code></pre></p>"},{"location":"api/core/#redlockconfiguration-class","title":"RedlockConfiguration Class","text":"<p>Configuration for Redlock behavior.</p>"},{"location":"api/core/#builder","title":"Builder","text":"<pre><code>RedlockConfiguration config = RedlockConfiguration.builder()\n    .retryCount(3)\n    .retryDelay(200)\n    .clockDriftFactor(0.01)\n    .build();\n</code></pre>"},{"location":"api/core/#properties","title":"Properties","text":"Property Type Default Description <code>retryCount</code> int 3 Number of retry attempts <code>retryDelay</code> int 200 Delay between retries (ms) <code>clockDriftFactor</code> double 0.01 Clock drift compensation factor <p>Example: <pre><code>RedlockConfiguration config = RedlockConfiguration.builder()\n    .retryCount(5)\n    .retryDelay(100)\n    .clockDriftFactor(0.02)\n    .build();\n\nRedlock redlock = new Redlock(config, pool1, pool2, pool3);\n</code></pre></p>"},{"location":"api/core/#exceptions","title":"Exceptions","text":""},{"location":"api/core/#redlockexception","title":"RedlockException","text":"<p>Base exception for Redlock operations.</p> <pre><code>try {\n    Lock lock = redlock.lock(\"resource\", 10000);\n} catch (RedlockException e) {\n    logger.error(\"Redlock error\", e);\n}\n</code></pre>"},{"location":"api/core/#lockacquisitionexception","title":"LockAcquisitionException","text":"<p>Thrown when lock acquisition fails critically.</p> <pre><code>try {\n    Lock lock = redlock.lock(\"resource\", 10000);\n} catch (LockAcquisitionException e) {\n    logger.error(\"Failed to acquire lock\", e);\n}\n</code></pre>"},{"location":"api/core/#thread-safety","title":"Thread Safety","text":"<p>All Redlock methods are thread-safe and can be called concurrently from multiple threads.</p> <pre><code>// Safe to use from multiple threads\nRedlock redlock = new Redlock(pool1, pool2, pool3);\n\n// Thread 1\nLock lock1 = redlock.lock(\"resource-1\", 10000);\n\n// Thread 2 (concurrent)\nLock lock2 = redlock.lock(\"resource-2\", 10000);\n</code></pre>"},{"location":"api/core/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration API - Configuration details</li> <li>Basic Usage - Usage examples</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#maven","title":"Maven","text":"<p>Add the following dependency to your <code>pom.xml</code>:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.codarama&lt;/groupId&gt;\n    &lt;artifactId&gt;redlock4j&lt;/artifactId&gt;\n    &lt;version&gt;1.1.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>You'll also need to add a Redis client dependency. Redlock4j supports both Jedis and Lettuce:</p>"},{"location":"getting-started/installation/#using-jedis","title":"Using Jedis","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;redis.clients&lt;/groupId&gt;\n    &lt;artifactId&gt;jedis&lt;/artifactId&gt;\n    &lt;version&gt;7.1.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"getting-started/installation/#using-lettuce","title":"Using Lettuce","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;\n    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;\n    &lt;version&gt;7.1.0.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"getting-started/installation/#gradle","title":"Gradle","text":"<p>Add the following to your <code>build.gradle</code>:</p> <pre><code>dependencies {\n    implementation 'org.codarama:redlock4j:1.1.0'\n\n    // Choose one Redis client:\n    // For Jedis:\n    implementation 'redis.clients:jedis:7.1.0'\n\n    // Or for Lettuce:\n    implementation 'io.lettuce:lettuce-core:7.1.0.RELEASE'\n}\n</code></pre>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Java 8 or higher</li> <li>Redis 2.6.12 or higher (for Lua script support)</li> <li>One of the supported Redis clients:<ul> <li>Jedis 3.0+ or 4.0+</li> <li>Lettuce 5.0+ or 6.0+</li> </ul> </li> </ul>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>After adding the dependencies, verify the installation by creating a simple test:</p> <pre><code>import org.codarama.redlock4j.Redlock;\nimport redis.clients.jedis.JedisPool;\n\npublic class RedlockTest {\n    public static void main(String[] args) {\n        JedisPool pool = new JedisPool(\"localhost\", 6379);\n        Redlock redlock = new Redlock(pool);\n        System.out.println(\"Redlock4j is ready!\");\n        pool.close();\n    }\n}\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Learn the basics</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>This guide will help you get started with Redlock4j in just a few minutes.</p>"},{"location":"getting-started/quick-start/#basic-setup","title":"Basic Setup","text":""},{"location":"getting-started/quick-start/#1-create-redis-connection-pools","title":"1. Create Redis Connection Pools","text":"<p>First, create connection pools for your Redis instances. For production use, you should have at least 3 independent Redis instances.</p> <pre><code>import redis.clients.jedis.JedisPool;\n\n// Create pools for multiple Redis instances\nJedisPool pool1 = new JedisPool(\"redis1.example.com\", 6379);\nJedisPool pool2 = new JedisPool(\"redis2.example.com\", 6379);\nJedisPool pool3 = new JedisPool(\"redis3.example.com\", 6379);\n</code></pre>"},{"location":"getting-started/quick-start/#2-create-a-redlock-instance","title":"2. Create a Redlock Instance","text":"<pre><code>import org.codarama.redlock4j.Redlock;\n\nRedlock redlock = new Redlock(pool1, pool2, pool3);\n</code></pre>"},{"location":"getting-started/quick-start/#3-acquire-and-release-locks","title":"3. Acquire and Release Locks","text":"<pre><code>import org.codarama.redlock4j.Lock;\n\n// Try to acquire a lock for \"my-resource\" with 10 second TTL\nLock lock = redlock.lock(\"my-resource\", 10000);\n\nif (lock != null) {\n    try {\n        // Lock acquired successfully\n        // Perform your critical section here\n        System.out.println(\"Lock acquired! Performing critical operation...\");\n        performCriticalOperation();\n    } finally {\n        // Always release the lock\n        redlock.unlock(lock);\n        System.out.println(\"Lock released\");\n    }\n} else {\n    // Failed to acquire lock\n    System.out.println(\"Could not acquire lock\");\n}\n</code></pre>"},{"location":"getting-started/quick-start/#complete-example","title":"Complete Example","text":"<p>Here's a complete working example:</p> <pre><code>import org.codarama.redlock4j.Redlock;\nimport org.codarama.redlock4j.Lock;\nimport redis.clients.jedis.JedisPool;\n\npublic class RedlockExample {\n    public static void main(String[] args) {\n        // Setup Redis pools\n        JedisPool pool1 = new JedisPool(\"localhost\", 6379);\n        JedisPool pool2 = new JedisPool(\"localhost\", 6380);\n        JedisPool pool3 = new JedisPool(\"localhost\", 6381);\n\n        // Create Redlock instance\n        Redlock redlock = new Redlock(pool1, pool2, pool3);\n\n        // Resource identifier\n        String resourceId = \"shared-resource\";\n\n        // Lock TTL in milliseconds (10 seconds)\n        int ttl = 10000;\n\n        // Try to acquire lock\n        Lock lock = redlock.lock(resourceId, ttl);\n\n        if (lock != null) {\n            try {\n                // Critical section\n                System.out.println(\"Processing shared resource...\");\n                Thread.sleep(2000); // Simulate work\n                System.out.println(\"Done processing\");\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            } finally {\n                // Release lock\n                redlock.unlock(lock);\n            }\n        } else {\n            System.out.println(\"Another process is using the resource\");\n        }\n\n        // Cleanup\n        pool1.close();\n        pool2.close();\n        pool3.close();\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#using-lettuce-instead-of-jedis","title":"Using Lettuce Instead of Jedis","text":"<p>If you prefer Lettuce over Jedis:</p> <pre><code>import io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport org.codarama.redlock4j.Redlock;\n\n// Create Lettuce clients\nRedisClient client1 = RedisClient.create(\"redis://localhost:6379\");\nRedisClient client2 = RedisClient.create(\"redis://localhost:6380\");\nRedisClient client3 = RedisClient.create(\"redis://localhost:6381\");\n\n// Create Redlock instance\nRedlock redlock = new Redlock(client1, client2, client3);\n\n// Use the same lock/unlock pattern as above\n</code></pre>"},{"location":"getting-started/quick-start/#important-notes","title":"Important Notes","text":"<p>Lock TTL</p> <p>Always set a TTL that's longer than your critical section execution time. If the lock expires while you're still processing, another client might acquire the lock.</p> <p>Always Unlock</p> <p>Always release locks in a <code>finally</code> block to ensure they're released even if an exception occurs.</p> <p>Minimum Redis Instances</p> <p>For production use, always use at least 3 independent Redis instances to ensure proper fault tolerance.</p>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Basic Usage - Explore more usage patterns</li> <li>Advanced Locking - Learn about advanced features</li> </ul>"},{"location":"guide/advanced-locking/","title":"Advanced Locking","text":"<p>Redlock4j provides advanced distributed synchronization primitives beyond basic locks.</p>"},{"location":"guide/advanced-locking/#fair-lock","title":"Fair Lock","text":"<p>Fair locks ensure FIFO ordering for lock acquisition, preventing thread starvation.</p>"},{"location":"guide/advanced-locking/#usage","title":"Usage","text":"<pre><code>Lock fairLock = redlockManager.createFairLock(\"fair-resource\");\n\nfairLock.lock();\ntry {\n    // Critical section - guaranteed FIFO ordering\n    performWork();\n} finally {\n    fairLock.unlock();\n}\n</code></pre>"},{"location":"guide/advanced-locking/#use-cases","title":"Use Cases","text":"<ul> <li>High-contention scenarios requiring fairness</li> <li>Preventing thread starvation</li> <li>Maintaining request ordering in distributed systems</li> </ul>"},{"location":"guide/advanced-locking/#multi-lock","title":"Multi-Lock","text":"<p>Atomic acquisition of multiple resources simultaneously, preventing deadlocks.</p>"},{"location":"guide/advanced-locking/#usage_1","title":"Usage","text":"<pre><code>MultiLock multiLock = redlockManager.createMultiLock(\"resource-1\", \"resource-2\", \"resource-3\");\n\nmultiLock.lock();\ntry {\n    // All resources locked atomically\n    processMultipleResources();\n} finally {\n    multiLock.unlock();\n}\n</code></pre>"},{"location":"guide/advanced-locking/#use-cases_1","title":"Use Cases","text":"<ul> <li>Database transactions across multiple tables</li> <li>Coordinating access to multiple shared resources</li> <li>Preventing circular wait deadlocks</li> </ul>"},{"location":"guide/advanced-locking/#read-write-lock","title":"Read-Write Lock","text":"<p>Separate read and write locks for improved concurrency.</p>"},{"location":"guide/advanced-locking/#usage_2","title":"Usage","text":"<pre><code>ReadWriteLock rwLock = redlockManager.createReadWriteLock(\"shared-data\");\n\n// Multiple readers can acquire simultaneously\nrwLock.readLock().lock();\ntry {\n    // Read operation\n    data = readData();\n} finally {\n    rwLock.readLock().unlock();\n}\n\n// Writers get exclusive access\nrwLock.writeLock().lock();\ntry {\n    // Write operation\n    writeData(newData);\n} finally {\n    rwLock.writeLock().unlock();\n}\n</code></pre>"},{"location":"guide/advanced-locking/#use-cases_2","title":"Use Cases","text":"<ul> <li>Read-heavy workloads</li> <li>Caching scenarios</li> <li>Shared configuration data</li> </ul>"},{"location":"guide/advanced-locking/#distributed-semaphore","title":"Distributed Semaphore","text":"<p>Control access to a limited number of resources.</p>"},{"location":"guide/advanced-locking/#usage_3","title":"Usage","text":"<pre><code>Semaphore semaphore = redlockManager.createSemaphore(\"resource-pool\", 5); // 5 permits\n\nsemaphore.acquire();\ntry {\n    // Use limited resource\n    useResource();\n} finally {\n    semaphore.release();\n}\n</code></pre>"},{"location":"guide/advanced-locking/#use-cases_3","title":"Use Cases","text":"<ul> <li>Connection pool management</li> <li>Rate limiting</li> <li>Resource quota enforcement</li> </ul>"},{"location":"guide/advanced-locking/#countdownlatch","title":"CountDownLatch","text":"<p>Coordinate multiple distributed processes.</p>"},{"location":"guide/advanced-locking/#usage_4","title":"Usage","text":"<pre><code>CountDownLatch latch = redlockManager.createCountDownLatch(\"startup-latch\", 3);\n\n// Worker threads\nlatch.countDown();\n\n// Coordinator thread\nlatch.await(); // Waits until count reaches 0\n</code></pre>"},{"location":"guide/advanced-locking/#use-cases_4","title":"Use Cases","text":"<ul> <li>Distributed initialization</li> <li>Barrier synchronization</li> <li>Coordinating parallel tasks</li> </ul>"},{"location":"guide/advanced-locking/#best-practices","title":"Best Practices","text":""},{"location":"guide/advanced-locking/#choose-the-right-primitive","title":"Choose the Right Primitive","text":"<ul> <li>Basic Lock: Simple mutual exclusion</li> <li>Fair Lock: When ordering matters</li> <li>Multi-Lock: Multiple resources needed atomically</li> <li>Read-Write Lock: Read-heavy workloads</li> <li>Semaphore: Limited resource pool</li> <li>CountDownLatch: Coordination between processes</li> </ul>"},{"location":"guide/advanced-locking/#timeout-configuration","title":"Timeout Configuration","text":"<p>Always use timeouts to prevent indefinite blocking:</p> <pre><code>boolean acquired = lock.tryLock(5, TimeUnit.SECONDS);\nif (acquired) {\n    try {\n        // Critical section\n    } finally {\n        lock.unlock();\n    }\n} else {\n    // Handle timeout\n}\n</code></pre>"},{"location":"guide/advanced-locking/#error-handling","title":"Error Handling","text":"<p>Properly handle failures:</p> <pre><code>Lock lock = null;\ntry {\n    lock = redlockManager.createLock(\"resource\");\n    lock.lock();\n    // Critical section\n} catch (Exception e) {\n    logger.error(\"Error in critical section\", e);\n} finally {\n    if (lock != null) {\n        try {\n            lock.unlock();\n        } catch (Exception e) {\n            logger.error(\"Error releasing lock\", e);\n        }\n    }\n}\n</code></pre>"},{"location":"guide/advanced-locking/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Fair locks have higher overhead than regular locks</li> <li>Multi-locks require more Redis operations</li> <li>Read-write locks optimize for read-heavy scenarios</li> <li>Semaphores scale with permit count</li> </ul>"},{"location":"guide/advanced-locking/#next-steps","title":"Next Steps","text":"<ul> <li>Best Practices - Follow recommended practices</li> <li>API Reference - Detailed API documentation</li> </ul> <p>For complete details, see ADVANCED_LOCKING.md in the repository.</p>"},{"location":"guide/basic-usage/","title":"Basic Usage","text":"<p>This guide covers common usage patterns and scenarios for Redlock4j.</p>"},{"location":"guide/basic-usage/#simple-lock-pattern","title":"Simple Lock Pattern","text":"<p>The most basic usage pattern:</p> <pre><code>Lock lock = redlock.lock(\"resource-id\", 10000);\nif (lock != null) {\n    try {\n        // Critical section\n    } finally {\n        redlock.unlock(lock);\n    }\n}\n</code></pre>"},{"location":"guide/basic-usage/#try-lock-pattern","title":"Try-Lock Pattern","text":"<p>Attempt to acquire a lock without retries:</p> <pre><code>Lock lock = redlock.tryLock(\"resource-id\", 10000);\nif (lock != null) {\n    try {\n        // Got the lock immediately\n    } finally {\n        redlock.unlock(lock);\n    }\n} else {\n    // Lock not available, handle accordingly\n}\n</code></pre>"},{"location":"guide/basic-usage/#lock-with-timeout","title":"Lock with Timeout","text":"<p>Wait for a lock with a timeout:</p> <pre><code>Lock lock = redlock.lock(\"resource-id\", 10000, 5000); // 5 second timeout\nif (lock != null) {\n    try {\n        // Acquired lock within timeout\n    } finally {\n        redlock.unlock(lock);\n    }\n} else {\n    // Timeout expired\n}\n</code></pre>"},{"location":"guide/basic-usage/#extending-lock-duration","title":"Extending Lock Duration","text":"<p>If your operation takes longer than expected, you can extend the lock:</p> <pre><code>Lock lock = redlock.lock(\"resource-id\", 10000);\nif (lock != null) {\n    try {\n        // Do some work\n        performPartialWork();\n\n        // Need more time, extend the lock\n        boolean extended = redlock.extend(lock, 10000);\n        if (extended) {\n            // Continue working\n            performMoreWork();\n        }\n    } finally {\n        redlock.unlock(lock);\n    }\n}\n</code></pre>"},{"location":"guide/basic-usage/#checking-lock-validity","title":"Checking Lock Validity","text":"<p>Check if a lock is still valid:</p> <pre><code>Lock lock = redlock.lock(\"resource-id\", 10000);\nif (lock != null) {\n    try {\n        performWork();\n\n        if (redlock.isValid(lock)) {\n            // Lock is still valid\n            performMoreWork();\n        } else {\n            // Lock expired or was released\n            handleExpiredLock();\n        }\n    } finally {\n        redlock.unlock(lock);\n    }\n}\n</code></pre>"},{"location":"guide/basic-usage/#multiple-resources","title":"Multiple Resources","text":"<p>Lock multiple resources atomically:</p> <pre><code>String[] resources = {\"resource-1\", \"resource-2\", \"resource-3\"};\nLock lock = redlock.lock(resources, 10000);\n\nif (lock != null) {\n    try {\n        // All resources are locked\n        processMultipleResources();\n    } finally {\n        redlock.unlock(lock);\n    }\n}\n</code></pre>"},{"location":"guide/basic-usage/#reentrant-locks","title":"Reentrant Locks","text":"<p>Redlock4j supports reentrant locks (same thread can acquire the same lock multiple times):</p> <pre><code>Lock lock1 = redlock.lock(\"resource-id\", 10000);\nif (lock1 != null) {\n    try {\n        // First acquisition\n\n        Lock lock2 = redlock.lock(\"resource-id\", 10000);\n        if (lock2 != null) {\n            try {\n                // Second acquisition by same thread\n            } finally {\n                redlock.unlock(lock2);\n            }\n        }\n    } finally {\n        redlock.unlock(lock1);\n    }\n}\n</code></pre>"},{"location":"guide/basic-usage/#error-handling","title":"Error Handling","text":"<p>Proper error handling is crucial:</p> <pre><code>Lock lock = null;\ntry {\n    lock = redlock.lock(\"resource-id\", 10000);\n    if (lock != null) {\n        // Critical section\n        performCriticalOperation();\n    } else {\n        // Failed to acquire lock\n        logger.warn(\"Could not acquire lock for resource-id\");\n        handleLockFailure();\n    }\n} catch (Exception e) {\n    logger.error(\"Error during critical section\", e);\n    handleError(e);\n} finally {\n    if (lock != null) {\n        try {\n            redlock.unlock(lock);\n        } catch (Exception e) {\n            logger.error(\"Error releasing lock\", e);\n        }\n    }\n}\n</code></pre>"},{"location":"guide/basic-usage/#using-with-try-with-resources","title":"Using with Try-With-Resources","text":"<p>If your Lock implementation supports AutoCloseable:</p> <pre><code>try (Lock lock = redlock.lock(\"resource-id\", 10000)) {\n    if (lock != null) {\n        // Critical section\n        performCriticalOperation();\n    }\n} // Lock automatically released\n</code></pre>"},{"location":"guide/basic-usage/#common-patterns","title":"Common Patterns","text":""},{"location":"guide/basic-usage/#singleton-task-execution","title":"Singleton Task Execution","text":"<p>Ensure only one instance executes a task:</p> <pre><code>public void executeScheduledTask() {\n    Lock lock = redlock.lock(\"scheduled-task-id\", 60000);\n    if (lock != null) {\n        try {\n            // Only one instance will execute this\n            performScheduledTask();\n        } finally {\n            redlock.unlock(lock);\n        }\n    } else {\n        // Another instance is already executing\n        logger.info(\"Task already running on another instance\");\n    }\n}\n</code></pre>"},{"location":"guide/basic-usage/#resource-pool-management","title":"Resource Pool Management","text":"<p>Manage access to a limited resource pool:</p> <pre><code>public void processWithResource(String resourceId) {\n    Lock lock = redlock.lock(\"resource-pool:\" + resourceId, 30000);\n    if (lock != null) {\n        try {\n            Resource resource = acquireResource(resourceId);\n            processResource(resource);\n        } finally {\n            redlock.unlock(lock);\n        }\n    }\n}\n</code></pre>"},{"location":"guide/basic-usage/#next-steps","title":"Next Steps","text":"<ul> <li>Advanced Locking - Learn about advanced features</li> <li>Best Practices - Follow recommended practices</li> </ul>"},{"location":"guide/best-practices/","title":"Best Practices","text":"<p>Follow these best practices to use Redlock4j effectively and safely in production.</p>"},{"location":"guide/best-practices/#lock-management","title":"Lock Management","text":""},{"location":"guide/best-practices/#always-release-locks","title":"Always Release Locks","text":"<p>Always release locks in a <code>finally</code> block:</p> <pre><code>Lock lock = redlock.lock(\"resource\", 10000);\nif (lock != null) {\n    try {\n        // Critical section\n    } finally {\n        redlock.unlock(lock);  // Always execute\n    }\n}\n</code></pre>"},{"location":"guide/best-practices/#check-lock-acquisition","title":"Check Lock Acquisition","text":"<p>Always check if lock acquisition succeeded:</p> <pre><code>Lock lock = redlock.lock(\"resource\", 10000);\nif (lock != null) {\n    // Lock acquired successfully\n} else {\n    // Failed to acquire lock - handle appropriately\n    handleLockFailure();\n}\n</code></pre>"},{"location":"guide/best-practices/#use-appropriate-ttl","title":"Use Appropriate TTL","text":"<p>Set TTL longer than your operation:</p> <pre><code>// Bad: TTL too short\nLock lock = redlock.lock(\"resource\", 1000);  // 1 second\nperformLongOperation();  // Takes 5 seconds - lock will expire!\n\n// Good: TTL with safety margin\nLock lock = redlock.lock(\"resource\", 10000);  // 10 seconds\nperformLongOperation();  // Takes 5 seconds - safe\n</code></pre>"},{"location":"guide/best-practices/#redis-configuration","title":"Redis Configuration","text":""},{"location":"guide/best-practices/#use-independent-redis-instances","title":"Use Independent Redis Instances","text":"<p>For production, use truly independent Redis instances:</p> <pre><code>// Good: Independent instances on different servers\nRedlock redlock = new Redlock(\n    new JedisPool(\"redis1.example.com\", 6379),\n    new JedisPool(\"redis2.example.com\", 6379),\n    new JedisPool(\"redis3.example.com\", 6379)\n);\n\n// Bad: Master-slave replication (not independent)\n// Don't use master and its slaves as separate instances\n</code></pre>"},{"location":"guide/best-practices/#minimum-3-instances","title":"Minimum 3 Instances","text":"<p>Always use at least 3 Redis instances:</p> <pre><code>// Minimum for fault tolerance\nRedlock redlock = new Redlock(pool1, pool2, pool3);\n\n// Better: 5 instances for higher availability\nRedlock redlock = new Redlock(pool1, pool2, pool3, pool4, pool5);\n</code></pre>"},{"location":"guide/best-practices/#use-odd-numbers","title":"Use Odd Numbers","text":"<p>Always use an odd number of instances:</p> <ul> <li>\u2705 3, 5, 7 instances</li> <li>\u274c 2, 4, 6 instances</li> </ul>"},{"location":"guide/best-practices/#error-handling","title":"Error Handling","text":""},{"location":"guide/best-practices/#handle-lock-failures","title":"Handle Lock Failures","text":"<pre><code>Lock lock = redlock.lock(\"resource\", 10000);\nif (lock == null) {\n    // Log the failure\n    logger.warn(\"Failed to acquire lock for resource\");\n\n    // Implement fallback strategy\n    // Option 1: Retry later\n    scheduleRetry();\n\n    // Option 2: Return error to caller\n    throw new LockAcquisitionException(\"Could not acquire lock\");\n\n    // Option 3: Use alternative approach\n    performAlternativeOperation();\n}\n</code></pre>"},{"location":"guide/best-practices/#handle-exceptions","title":"Handle Exceptions","text":"<pre><code>Lock lock = null;\ntry {\n    lock = redlock.lock(\"resource\", 10000);\n    if (lock != null) {\n        performCriticalOperation();\n    }\n} catch (Exception e) {\n    logger.error(\"Error in critical section\", e);\n    handleError(e);\n} finally {\n    if (lock != null) {\n        try {\n            redlock.unlock(lock);\n        } catch (Exception e) {\n            logger.error(\"Error releasing lock\", e);\n            // Don't throw - we're in finally block\n        }\n    }\n}\n</code></pre>"},{"location":"guide/best-practices/#performance","title":"Performance","text":""},{"location":"guide/best-practices/#reuse-redlock-instances","title":"Reuse Redlock Instances","text":"<p>Create Redlock instances once and reuse:</p> <pre><code>// Good: Singleton pattern\npublic class LockService {\n    private static final Redlock REDLOCK = createRedlock();\n\n    public Lock acquireLock(String resource) {\n        return REDLOCK.lock(resource, 10000);\n    }\n}\n\n// Bad: Creating new instance each time\npublic Lock acquireLock(String resource) {\n    Redlock redlock = new Redlock(pool1, pool2, pool3);  // Wasteful!\n    return redlock.lock(resource, 10000);\n}\n</code></pre>"},{"location":"guide/best-practices/#configure-connection-pools","title":"Configure Connection Pools","text":"<p>Properly configure connection pools:</p> <pre><code>JedisPoolConfig config = new JedisPoolConfig();\nconfig.setMaxTotal(128);        // Enough for your load\nconfig.setMaxIdle(64);          // Keep some idle connections\nconfig.setMinIdle(16);          // Minimum ready connections\nconfig.setTestOnBorrow(true);   // Validate connections\nconfig.setTestWhileIdle(true);  // Clean up stale connections\n</code></pre>"},{"location":"guide/best-practices/#use-appropriate-retry-settings","title":"Use Appropriate Retry Settings","text":"<pre><code>RedlockConfiguration config = RedlockConfiguration.builder()\n    .retryCount(3)      // Don't retry too many times\n    .retryDelay(200)    // Reasonable delay between retries\n    .build();\n</code></pre>"},{"location":"guide/best-practices/#resource-naming","title":"Resource Naming","text":""},{"location":"guide/best-practices/#use-descriptive-names","title":"Use Descriptive Names","text":"<pre><code>// Good: Clear and descriptive\nLock lock = redlock.lock(\"user:123:profile:update\", 10000);\nLock lock = redlock.lock(\"order:456:payment:process\", 10000);\n\n// Bad: Unclear names\nLock lock = redlock.lock(\"lock1\", 10000);\nLock lock = redlock.lock(\"temp\", 10000);\n</code></pre>"},{"location":"guide/best-practices/#use-consistent-naming-convention","title":"Use Consistent Naming Convention","text":"<pre><code>// Establish a pattern\nString lockKey = String.format(\"%s:%s:%s\", \n    entityType,    // \"user\", \"order\", \"product\"\n    entityId,      // \"123\", \"456\"\n    operation      // \"update\", \"delete\", \"process\"\n);\n</code></pre>"},{"location":"guide/best-practices/#monitoring-and-logging","title":"Monitoring and Logging","text":""},{"location":"guide/best-practices/#log-lock-operations","title":"Log Lock Operations","text":"<pre><code>Lock lock = redlock.lock(resourceId, ttl);\nif (lock != null) {\n    logger.info(\"Acquired lock for resource: {}\", resourceId);\n    try {\n        performOperation();\n    } finally {\n        redlock.unlock(lock);\n        logger.info(\"Released lock for resource: {}\", resourceId);\n    }\n} else {\n    logger.warn(\"Failed to acquire lock for resource: {}\", resourceId);\n}\n</code></pre>"},{"location":"guide/best-practices/#monitor-lock-metrics","title":"Monitor Lock Metrics","text":"<p>Track important metrics:</p> <ul> <li>Lock acquisition success rate</li> <li>Lock acquisition latency</li> <li>Lock hold time</li> <li>Lock contention rate</li> </ul>"},{"location":"guide/best-practices/#testing","title":"Testing","text":""},{"location":"guide/best-practices/#test-lock-behavior","title":"Test Lock Behavior","text":"<pre><code>@Test\npublic void testLockAcquisition() {\n    Lock lock = redlock.lock(\"test-resource\", 10000);\n    assertNotNull(lock, \"Should acquire lock\");\n\n    // Try to acquire same lock - should fail\n    Lock lock2 = redlock.tryLock(\"test-resource\", 10000);\n    assertNull(lock2, \"Should not acquire already locked resource\");\n\n    redlock.unlock(lock);\n}\n</code></pre>"},{"location":"guide/best-practices/#use-testcontainers","title":"Use Testcontainers","text":"<p>For integration tests:</p> <pre><code>@Testcontainers\npublic class RedlockIntegrationTest {\n    @Container\n    private static GenericContainer&lt;?&gt; redis = \n        new GenericContainer&lt;&gt;(\"redis:7-alpine\")\n            .withExposedPorts(6379);\n\n    @Test\n    public void testWithRealRedis() {\n        JedisPool pool = new JedisPool(\n            redis.getHost(), \n            redis.getFirstMappedPort()\n        );\n        Redlock redlock = new Redlock(pool);\n        // Test with real Redis\n    }\n}\n</code></pre>"},{"location":"guide/best-practices/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"guide/best-practices/#dont-forget-to-unlock","title":"\u274c Don't Forget to Unlock","text":"<pre><code>// Bad: No unlock\nLock lock = redlock.lock(\"resource\", 10000);\nperformOperation();  // If this throws, lock is never released!\n</code></pre>"},{"location":"guide/best-practices/#dont-use-same-redis-instance-multiple-times","title":"\u274c Don't Use Same Redis Instance Multiple Times","text":"<pre><code>// Bad: Same instance counted 3 times\nRedlock redlock = new Redlock(pool, pool, pool);  // Wrong!\n</code></pre>"},{"location":"guide/best-practices/#dont-ignore-lock-acquisition-failures","title":"\u274c Don't Ignore Lock Acquisition Failures","text":"<pre><code>// Bad: Assuming lock is always acquired\nLock lock = redlock.lock(\"resource\", 10000);\nperformOperation();  // What if lock is null?\n</code></pre>"},{"location":"guide/best-practices/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Detailed API documentation</li> <li>Advanced Locking - Advanced features</li> </ul>"},{"location":"guide/redis-clients/","title":"Redis Clients","text":"<p>Redlock4j supports both Jedis and Lettuce Redis clients through a clean driver abstraction.</p>"},{"location":"guide/redis-clients/#jedis","title":"Jedis","text":"<p>Jedis is a synchronous Redis client that's simple and straightforward.</p>"},{"location":"guide/redis-clients/#setup","title":"Setup","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;redis.clients&lt;/groupId&gt;\n    &lt;artifactId&gt;jedis&lt;/artifactId&gt;\n    &lt;version&gt;7.1.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"guide/redis-clients/#basic-usage","title":"Basic Usage","text":"<pre><code>import redis.clients.jedis.JedisPool;\nimport org.codarama.redlock4j.Redlock;\n\nJedisPool pool1 = new JedisPool(\"localhost\", 6379);\nJedisPool pool2 = new JedisPool(\"localhost\", 6380);\nJedisPool pool3 = new JedisPool(\"localhost\", 6381);\n\nRedlock redlock = new Redlock(pool1, pool2, pool3);\n</code></pre>"},{"location":"guide/redis-clients/#connection-pool-configuration","title":"Connection Pool Configuration","text":"<pre><code>import redis.clients.jedis.JedisPoolConfig;\n\nJedisPoolConfig config = new JedisPoolConfig();\nconfig.setMaxTotal(128);\nconfig.setMaxIdle(128);\nconfig.setMinIdle(16);\nconfig.setTestOnBorrow(true);\nconfig.setTestOnReturn(true);\nconfig.setTestWhileIdle(true);\nconfig.setMinEvictableIdleTimeMillis(60000);\nconfig.setTimeBetweenEvictionRunsMillis(30000);\nconfig.setNumTestsPerEvictionRun(3);\nconfig.setBlockWhenExhausted(true);\n\nJedisPool pool = new JedisPool(config, \"localhost\", 6379, 2000);\n</code></pre>"},{"location":"guide/redis-clients/#advantages","title":"Advantages","text":"<ul> <li>Simple and easy to use</li> <li>Synchronous API is straightforward</li> <li>Lower memory footprint</li> <li>Good for simple use cases</li> </ul>"},{"location":"guide/redis-clients/#disadvantages","title":"Disadvantages","text":"<ul> <li>Blocking I/O</li> <li>Less efficient for high-throughput scenarios</li> <li>No built-in async support</li> </ul>"},{"location":"guide/redis-clients/#lettuce","title":"Lettuce","text":"<p>Lettuce is an advanced Redis client with async and reactive support.</p>"},{"location":"guide/redis-clients/#setup_1","title":"Setup","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;\n    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;\n    &lt;version&gt;7.1.0.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"guide/redis-clients/#basic-usage_1","title":"Basic Usage","text":"<pre><code>import io.lettuce.core.RedisClient;\nimport org.codarama.redlock4j.Redlock;\n\nRedisClient client1 = RedisClient.create(\"redis://localhost:6379\");\nRedisClient client2 = RedisClient.create(\"redis://localhost:6380\");\nRedisClient client3 = RedisClient.create(\"redis://localhost:6381\");\n\nRedlock redlock = new Redlock(client1, client2, client3);\n</code></pre>"},{"location":"guide/redis-clients/#advanced-configuration","title":"Advanced Configuration","text":"<pre><code>import io.lettuce.core.RedisURI;\nimport io.lettuce.core.ClientOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport io.lettuce.core.resource.ClientResources;\nimport io.lettuce.core.resource.DefaultClientResources;\nimport java.time.Duration;\n\n// Configure client resources\nClientResources resources = DefaultClientResources.builder()\n    .ioThreadPoolSize(4)\n    .computationThreadPoolSize(4)\n    .build();\n\n// Configure Redis URI\nRedisURI redisUri = RedisURI.builder()\n    .withHost(\"localhost\")\n    .withPort(6379)\n    .withTimeout(Duration.ofSeconds(5))\n    .withDatabase(0)\n    .build();\n\n// Configure client options\nClientOptions options = ClientOptions.builder()\n    .autoReconnect(true)\n    .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(5)))\n    .build();\n\nRedisClient client = RedisClient.create(resources, redisUri);\nclient.setOptions(options);\n</code></pre>"},{"location":"guide/redis-clients/#advantages_1","title":"Advantages","text":"<ul> <li>Non-blocking I/O with Netty</li> <li>Async and reactive API support</li> <li>Better performance for high-throughput</li> <li>Advanced features (clustering, sentinel)</li> </ul>"},{"location":"guide/redis-clients/#disadvantages_1","title":"Disadvantages","text":"<ul> <li>More complex API</li> <li>Higher memory footprint</li> <li>Steeper learning curve</li> </ul>"},{"location":"guide/redis-clients/#choosing-between-jedis-and-lettuce","title":"Choosing Between Jedis and Lettuce","text":""},{"location":"guide/redis-clients/#use-jedis-when","title":"Use Jedis When:","text":"<ul> <li>You need a simple, straightforward API</li> <li>Your application is primarily synchronous</li> <li>You have moderate throughput requirements</li> <li>You want minimal dependencies</li> </ul>"},{"location":"guide/redis-clients/#use-lettuce-when","title":"Use Lettuce When:","text":"<ul> <li>You need high throughput</li> <li>You want async/reactive programming</li> <li>You're using Redis Cluster or Sentinel</li> <li>You need advanced features</li> </ul>"},{"location":"guide/redis-clients/#mixed-usage","title":"Mixed Usage","text":"<p>You can use different clients for different Redis instances:</p> <pre><code>// Mix Jedis and Lettuce (not recommended, but possible)\nJedisPool jedisPool = new JedisPool(\"localhost\", 6379);\nRedisClient lettuceClient1 = RedisClient.create(\"redis://localhost:6380\");\nRedisClient lettuceClient2 = RedisClient.create(\"redis://localhost:6381\");\n\n// This works, but stick to one client type for consistency\nRedlock redlock = new Redlock(jedisPool, lettuceClient1, lettuceClient2);\n</code></pre> <p>Consistency Recommendation</p> <p>While mixing clients is technically possible, it's recommended to use the same client type for all Redis instances for consistency and easier maintenance.</p>"},{"location":"guide/redis-clients/#connection-management","title":"Connection Management","text":""},{"location":"guide/redis-clients/#jedis_1","title":"Jedis","text":"<pre><code>// Always close pools when done\ntry {\n    // Use redlock\n} finally {\n    pool1.close();\n    pool2.close();\n    pool3.close();\n}\n</code></pre>"},{"location":"guide/redis-clients/#lettuce_1","title":"Lettuce","text":"<pre><code>// Shutdown clients and resources\ntry {\n    // Use redlock\n} finally {\n    client1.shutdown();\n    client2.shutdown();\n    client3.shutdown();\n    resources.shutdown();\n}\n</code></pre>"},{"location":"guide/redis-clients/#next-steps","title":"Next Steps","text":"<ul> <li>Best Practices - Follow recommended practices</li> <li>Configuration - Detailed configuration options</li> </ul>"}]}