{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Redlock4j","text":"<p>A robust Java implementation of the Redlock distributed locking algorithm for Redis.</p>"},{"location":"#overview","title":"Overview","text":"<p>Redlock4j provides a reliable distributed locking mechanism using Redis, implementing the Redlock algorithm proposed by Redis creator Antirez. It ensures mutual exclusion across distributed systems with high availability and fault tolerance.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Pure Redlock distributed locking algorithm - entirely based on Redis definition</li> <li>Multiple Redis Drivers: Integrated supports for Jedis and Lettuce, extensible to other drivers</li> <li>Lightweight - Minimum implementation, no extra scope outside locking</li> <li>Multi-interface API - Supports standard Lock, as well as async and reactive APIs</li> <li>Advanced Locking: Fair, multi &amp; read-write locks, semaphores, and countdown latches</li> <li>Lock Extension: Extend lock validity time without releasing and re-acquiring</li> <li>Atomic CAS/CAD: Auto-detects native Redis 8.4+ CAS/CAD commands when available</li> <li>Java 8+ - Compatible with Java 8 and higher</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>// Create a Redlock instance\nRedlock redlock = new Redlock(jedisPool1, jedisPool2, jedisPool3);\n\n// Acquire a lock\nLock lock = redlock.lock(\"my-resource\", 10000);\n\nif (lock != null) {\n    try {\n        // Critical section - your protected code here\n        performCriticalOperation();\n    } finally {\n        // Always unlock in a finally block\n        redlock.unlock(lock);\n    }\n} else {\n    // Failed to acquire lock\n    handleLockFailure();\n}\n</code></pre>"},{"location":"#why-redlock4j","title":"Why Redlock4j?","text":""},{"location":"#distributed-lock-guarantees","title":"Distributed Lock Guarantees","text":"<p>Redlock4j provides the following safety and liveness guarantees:</p> <ol> <li>Mutual Exclusion - At most one client can hold a lock at any given time</li> <li>Deadlock Free - Eventually it's always possible to acquire a lock, even if the client that locked a resource crashes</li> <li>Fault Tolerance - As long as the majority of Redis nodes are up, clients can acquire and release locks</li> </ol>"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>Distributed Task Scheduling - Ensure only one instance processes a scheduled task</li> <li>Resource Access Control - Coordinate access to shared resources across services</li> <li>Leader Election - Implement leader election in distributed systems</li> <li>Rate Limiting - Implement distributed rate limiting</li> <li>Cache Invalidation - Coordinate cache updates across multiple instances</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Check out the Installation Guide to add Redlock4j to your project, or jump straight to the Quick Start to see it in action.</p>"},{"location":"#license","title":"License","text":"<p>Redlock4j is released under the MIT License.</p>"},{"location":"comparison/","title":"Redlock4j vs Redisson","text":"<p>Comparison between Redlock4j and Redisson for distributed locking.</p>"},{"location":"comparison/#quick-comparison","title":"Quick Comparison","text":"Feature Redlock4j Redisson Algorithm Pure Redlock Single instance / Master-Slave API Standard Java Lock Custom RLock Dependencies Minimal Netty + many others Size ~10 core classes 50+ data structures Focus Distributed locking Full Redis framework Learning Curve Low Medium-High Redis Clients Jedis or Lettuce Built-in Netty client"},{"location":"comparison/#architecture","title":"Architecture","text":""},{"location":"comparison/#redlock4j","title":"Redlock4j","text":"<ul> <li>Pure Redlock Implementation: Follows the official Redlock algorithm</li> <li>Quorum-Based: Requires majority (N/2+1) of Redis nodes</li> <li>Multi-Master: Works with independent Redis instances</li> <li>Fault Tolerant: Survives minority node failures</li> </ul>"},{"location":"comparison/#redisson","title":"Redisson","text":"<ul> <li>Single Instance: Standard RLock uses single Redis</li> <li>Master-Slave: RedissonRedLock available but not default</li> <li>Full Framework: Comprehensive Redis client library</li> <li>Feature Rich: Many data structures beyond locks</li> </ul>"},{"location":"comparison/#api-comparison","title":"API Comparison","text":""},{"location":"comparison/#redlock4j-standard-java-lock","title":"Redlock4j - Standard Java Lock","text":"<pre><code>Lock lock = manager.createLock(\"resource\");\nlock.lock();\ntry {\n    // Critical section\n} finally {\n    lock.unlock();\n}\n</code></pre> <p>Advantages: - Familiar Java API - Drop-in replacement for <code>java.util.concurrent.locks.Lock</code> - No learning curve</p>"},{"location":"comparison/#redisson-custom-rlock","title":"Redisson - Custom RLock","text":"<pre><code>RLock lock = redisson.getLock(\"resource\");\nlock.lock();\ntry {\n    // Critical section\n} finally {\n    lock.unlock();\n}\n</code></pre> <p>Differences: - Custom <code>RLock</code> interface - Additional methods (tryLock with lease time, etc.) - Redisson-specific API</p>"},{"location":"comparison/#safety-guarantees","title":"Safety Guarantees","text":""},{"location":"comparison/#redlock4j_1","title":"Redlock4j","text":"<p>\u2705 True Distributed Lock - Requires majority of nodes to acquire lock - Survives minority node failures - Clock drift compensation - No single point of failure</p>"},{"location":"comparison/#redisson-standard-rlock","title":"Redisson Standard RLock","text":"<p>\u26a0\ufe0f Single Instance Lock - Uses single Redis instance - Master failure = lock unavailable - Replication lag can cause issues - Single point of failure</p>"},{"location":"comparison/#redisson-redissonredlock","title":"Redisson RedissonRedLock","text":"<p>\u2705 Redlock Implementation - Similar to Redlock4j - Requires explicit use of <code>RedissonRedLock</code> - Not the default locking mechanism</p>"},{"location":"comparison/#dependencies","title":"Dependencies","text":""},{"location":"comparison/#redlock4j_2","title":"Redlock4j","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.codarama&lt;/groupId&gt;\n    &lt;artifactId&gt;redlock4j&lt;/artifactId&gt;\n    &lt;version&gt;1.1.0&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!-- Plus your choice of Jedis or Lettuce --&gt;\n</code></pre> <p>Size: ~50KB Dependencies: Minimal (SLF4J + Redis client)</p>"},{"location":"comparison/#redisson_1","title":"Redisson","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.redisson&lt;/groupId&gt;\n    &lt;artifactId&gt;redisson&lt;/artifactId&gt;\n    &lt;version&gt;3.x.x&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Size: Several MB Dependencies: Netty, Jackson, many others</p>"},{"location":"comparison/#use-cases","title":"Use Cases","text":""},{"location":"comparison/#choose-redlock4j-when","title":"Choose Redlock4j When:","text":"<ul> <li>\u2705 You need true distributed locking</li> <li>\u2705 You want minimal dependencies</li> <li>\u2705 You prefer standard Java APIs</li> <li>\u2705 You need multi-master setup</li> <li>\u2705 You want lightweight library</li> </ul>"},{"location":"comparison/#choose-redisson-when","title":"Choose Redisson When:","text":"<ul> <li>\u2705 You need many Redis data structures</li> <li>\u2705 You want all-in-one framework</li> <li>\u2705 You need reactive/async APIs</li> <li>\u2705 You use Redis Cluster/Sentinel</li> <li>\u2705 Single instance locking is sufficient</li> </ul>"},{"location":"comparison/#performance","title":"Performance","text":""},{"location":"comparison/#redlock4j_3","title":"Redlock4j","text":"<ul> <li>Latency: Higher (requires majority quorum)</li> <li>Throughput: Moderate (multiple Redis calls)</li> <li>Network: More network calls</li> <li>Best For: Safety over speed</li> </ul>"},{"location":"comparison/#redisson_2","title":"Redisson","text":"<ul> <li>Latency: Lower (single instance)</li> <li>Throughput: Higher (single call)</li> <li>Network: Fewer network calls</li> <li>Best For: Speed over safety</li> </ul>"},{"location":"comparison/#migration","title":"Migration","text":""},{"location":"comparison/#from-redisson-to-redlock4j","title":"From Redisson to Redlock4j","text":"<pre><code>// Before (Redisson)\nRLock lock = redisson.getLock(\"resource\");\nlock.lock();\ntry {\n    // work\n} finally {\n    lock.unlock();\n}\n\n// After (Redlock4j)\nLock lock = manager.createLock(\"resource\");\nlock.lock();\ntry {\n    // work\n} finally {\n    lock.unlock();\n}\n</code></pre>"},{"location":"comparison/#from-redlock4j-to-redisson","title":"From Redlock4j to Redisson","text":"<pre><code>// Before (Redlock4j)\nLock lock = manager.createLock(\"resource\");\nlock.lock();\n\n// After (Redisson RedissonRedLock)\nRLock lock1 = redisson1.getLock(\"resource\");\nRLock lock2 = redisson2.getLock(\"resource\");\nRLock lock3 = redisson3.getLock(\"resource\");\nRedissonRedLock lock = new RedissonRedLock(lock1, lock2, lock3);\nlock.lock();\n</code></pre>"},{"location":"comparison/#detailed-comparisons","title":"Detailed Comparisons","text":"<p>For in-depth technical comparisons of specific features:</p> <ul> <li>FairLock Implementation - Detailed comparison of FairLock implementations between redlock4j and Redisson, including data structures, algorithms, and trade-offs</li> <li>MultiLock Implementation - Comprehensive comparison of MultiLock implementations, covering deadlock prevention, acquisition strategies, and use cases</li> <li>Semaphore Implementation - In-depth comparison of distributed semaphore implementations, analyzing permit management, performance, and consistency models</li> <li>ReadWriteLock Implementation - Detailed comparison of read-write lock implementations, covering reader/writer coordination, lock upgrade/downgrade, and performance characteristics</li> <li>CountDownLatch Implementation - Comprehensive comparison of countdown latch implementations, analyzing counting mechanisms, notification strategies, and consistency guarantees</li> </ul>"},{"location":"comparison/#conclusion","title":"Conclusion","text":"<p>Redlock4j is ideal for applications that: - Need true distributed locking guarantees - Want minimal dependencies - Prefer standard Java APIs - Value simplicity and focus</p> <p>Redisson is ideal for applications that: - Need comprehensive Redis functionality - Want a full-featured framework - Require reactive/async support - Can accept single-instance locking</p> <p>For complete comparison, see COMPARISON.md in the repository.</p>"},{"location":"api/configuration/","title":"Configuration API Reference","text":"<p>Detailed reference for configuring Redlock4j.</p>"},{"location":"api/configuration/#redlockconfiguration","title":"RedlockConfiguration","text":"<p>Main configuration class for Redlock behavior.</p>"},{"location":"api/configuration/#builder-pattern","title":"Builder Pattern","text":"<pre><code>RedlockConfiguration config = RedlockConfiguration.builder()\n    .retryCount(3)\n    .retryDelay(200)\n    .clockDriftFactor(0.01)\n    .build();\n</code></pre>"},{"location":"api/configuration/#configuration-properties","title":"Configuration Properties","text":""},{"location":"api/configuration/#retrycount","title":"retryCount","text":"<p>Number of times to retry lock acquisition if it fails.</p> <p>Type: <code>int</code> Default: <code>3</code> Range: <code>0</code> to <code>Integer.MAX_VALUE</code></p> <pre><code>RedlockConfiguration config = RedlockConfiguration.builder()\n    .retryCount(5)  // Retry up to 5 times\n    .build();\n</code></pre> <p>Use Cases: - High contention: Increase retry count - Low contention: Decrease for faster failure - Time-sensitive: Set to 0 for no retries</p>"},{"location":"api/configuration/#retrydelay","title":"retryDelay","text":"<p>Delay in milliseconds between retry attempts.</p> <p>Type: <code>int</code> Default: <code>200</code> Range: <code>0</code> to <code>Integer.MAX_VALUE</code></p> <pre><code>RedlockConfiguration config = RedlockConfiguration.builder()\n    .retryDelay(100)  // Wait 100ms between retries\n    .build();\n</code></pre> <p>Use Cases: - High contention: Increase delay to reduce Redis load - Low latency required: Decrease delay - Exponential backoff: Implement custom retry logic</p>"},{"location":"api/configuration/#clockdriftfactor","title":"clockDriftFactor","text":"<p>Factor to compensate for clock drift between Redis instances.</p> <p>Type: <code>double</code> Default: <code>0.01</code> (1%) Range: <code>0.0</code> to <code>1.0</code></p> <pre><code>RedlockConfiguration config = RedlockConfiguration.builder()\n    .clockDriftFactor(0.02)  // 2% clock drift\n    .build();\n</code></pre> <p>Formula: <pre><code>validity_time = ttl - elapsed_time - (ttl * clockDriftFactor)\n</code></pre></p> <p>Use Cases: - Synchronized clocks: Use smaller factor (0.001) - Unsynchronized clocks: Use larger factor (0.05) - Default: 0.01 is safe for most cases</p>"},{"location":"api/configuration/#complete-configuration-example","title":"Complete Configuration Example","text":"<pre><code>import org.codarama.redlock4j.Redlock;\nimport org.codarama.redlock4j.RedlockConfiguration;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\npublic class ConfigurationExample {\n    public static Redlock createRedlock() {\n        // Configure Jedis pools\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        poolConfig.setMaxTotal(128);\n        poolConfig.setMaxIdle(64);\n        poolConfig.setMinIdle(16);\n        poolConfig.setTestOnBorrow(true);\n        poolConfig.setTestWhileIdle(true);\n\n        JedisPool pool1 = new JedisPool(poolConfig, \"redis1.example.com\", 6379);\n        JedisPool pool2 = new JedisPool(poolConfig, \"redis2.example.com\", 6379);\n        JedisPool pool3 = new JedisPool(poolConfig, \"redis3.example.com\", 6379);\n\n        // Configure Redlock\n        RedlockConfiguration config = RedlockConfiguration.builder()\n            .retryCount(5)\n            .retryDelay(200)\n            .clockDriftFactor(0.01)\n            .build();\n\n        return new Redlock(config, pool1, pool2, pool3);\n    }\n}\n</code></pre>"},{"location":"api/configuration/#environment-specific-configurations","title":"Environment-Specific Configurations","text":""},{"location":"api/configuration/#development","title":"Development","text":"<pre><code>// Minimal configuration for development\nRedlockConfiguration devConfig = RedlockConfiguration.builder()\n    .retryCount(1)\n    .retryDelay(100)\n    .build();\n\n// Single Redis instance is acceptable for dev\nJedisPool devPool = new JedisPool(\"localhost\", 6379);\nRedlock devRedlock = new Redlock(devConfig, devPool);\n</code></pre>"},{"location":"api/configuration/#staging","title":"Staging","text":"<pre><code>// Moderate configuration for staging\nRedlockConfiguration stagingConfig = RedlockConfiguration.builder()\n    .retryCount(3)\n    .retryDelay(200)\n    .clockDriftFactor(0.01)\n    .build();\n\n// 3 Redis instances\nRedlock stagingRedlock = new Redlock(\n    stagingConfig,\n    new JedisPool(\"redis1.staging\", 6379),\n    new JedisPool(\"redis2.staging\", 6379),\n    new JedisPool(\"redis3.staging\", 6379)\n);\n</code></pre>"},{"location":"api/configuration/#production","title":"Production","text":"<pre><code>// Robust configuration for production\nRedlockConfiguration prodConfig = RedlockConfiguration.builder()\n    .retryCount(5)\n    .retryDelay(200)\n    .clockDriftFactor(0.01)\n    .build();\n\n// 5 Redis instances for high availability\nRedlock prodRedlock = new Redlock(\n    prodConfig,\n    new JedisPool(poolConfig, \"redis1.prod\", 6379),\n    new JedisPool(poolConfig, \"redis2.prod\", 6379),\n    new JedisPool(poolConfig, \"redis3.prod\", 6379),\n    new JedisPool(poolConfig, \"redis4.prod\", 6379),\n    new JedisPool(poolConfig, \"redis5.prod\", 6379)\n);\n</code></pre>"},{"location":"api/configuration/#redis-connection-configuration","title":"Redis Connection Configuration","text":""},{"location":"api/configuration/#jedis-pool-configuration","title":"Jedis Pool Configuration","text":"<p>Configure Jedis connection pools for optimal performance:</p> <pre><code>import redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\nJedisPoolConfig poolConfig = new JedisPoolConfig();\npoolConfig.setMaxTotal(128);\npoolConfig.setMaxIdle(128);\npoolConfig.setMinIdle(16);\npoolConfig.setTestOnBorrow(true);\npoolConfig.setTestOnReturn(true);\npoolConfig.setTestWhileIdle(true);\n\nJedisPool pool = new JedisPool(poolConfig, \"localhost\", 6379);\n</code></pre>"},{"location":"api/configuration/#lettuce-client-configuration","title":"Lettuce Client Configuration","text":"<p>Configure Lettuce clients:</p> <pre><code>import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.ClientOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport java.time.Duration;\n\nRedisURI redisUri = RedisURI.builder()\n    .withHost(\"localhost\")\n    .withPort(6379)\n    .withTimeout(Duration.ofSeconds(5))\n    .build();\n\nClientOptions options = ClientOptions.builder()\n    .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(5)))\n    .build();\n\nRedisClient client = RedisClient.create(redisUri);\nclient.setOptions(options);\n</code></pre>"},{"location":"api/configuration/#configuration-best-practices","title":"Configuration Best Practices","text":""},{"location":"api/configuration/#lock-ttl","title":"Lock TTL","text":"<p>Choose an appropriate TTL based on your use case:</p> <ul> <li>Short operations (&lt; 1 second): Use 5-10 second TTL</li> <li>Medium operations (1-10 seconds): Use 30-60 second TTL</li> <li>Long operations (&gt; 10 seconds): Consider if distributed locking is the right solution</li> </ul> <p>TTL Too Short</p> <p>If your TTL is too short, the lock might expire before your operation completes, allowing another client to acquire the lock.</p>"},{"location":"api/configuration/#retry-strategy","title":"Retry Strategy","text":"<ul> <li>High contention: Increase retry count and delay</li> <li>Low contention: Reduce retry count for faster failure</li> <li>Time-sensitive: Reduce retry count to fail fast</li> </ul> <pre><code>// High contention scenario\nRedlockConfiguration highContention = RedlockConfiguration.builder()\n    .retryCount(10)      // More retries\n    .retryDelay(500)     // Longer delay\n    .build();\n\n// Low latency requirement\nRedlockConfiguration lowLatency = RedlockConfiguration.builder()\n    .retryCount(1)       // Fail fast\n    .retryDelay(50)      // Short delay\n    .build();\n</code></pre>"},{"location":"api/configuration/#number-of-redis-instances","title":"Number of Redis Instances","text":"<ul> <li>Minimum: 3 instances for fault tolerance</li> <li>Recommended: 5 instances for high availability</li> <li>Odd number: Always use an odd number to ensure clear majority</li> </ul>"},{"location":"api/configuration/#clock-drift","title":"Clock Drift","text":"<pre><code>// Well-synchronized clocks (NTP)\nRedlockConfiguration syncedClocks = RedlockConfiguration.builder()\n    .clockDriftFactor(0.001)  // 0.1% drift\n    .build();\n\n// Unsynchronized clocks\nRedlockConfiguration unsyncedClocks = RedlockConfiguration.builder()\n    .clockDriftFactor(0.05)   // 5% drift\n    .build();\n</code></pre>"},{"location":"api/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Core API - Core API reference</li> <li>Basic Usage - Learn common usage patterns</li> </ul>"},{"location":"api/core/","title":"Core API Reference","text":"<p>This page documents the core API of Redlock4j.</p>"},{"location":"api/core/#redlock-class","title":"Redlock Class","text":"<p>The main class for creating and managing distributed locks.</p>"},{"location":"api/core/#constructor","title":"Constructor","text":"<pre><code>public Redlock(JedisPool... pools)\npublic Redlock(RedisClient... clients)\npublic Redlock(RedlockConfiguration config, JedisPool... pools)\npublic Redlock(RedlockConfiguration config, RedisClient... clients)\n</code></pre> <p>Parameters: - <code>config</code> - Configuration for Redlock behavior (optional) - <code>pools</code> - Jedis connection pools for Redis instances - <code>clients</code> - Lettuce Redis clients</p> <p>Example: <pre><code>Redlock redlock = new Redlock(pool1, pool2, pool3);\n</code></pre></p>"},{"location":"api/core/#lock","title":"lock()","text":"<p>Acquire a lock with retries.</p> <pre><code>public Lock lock(String resource, int ttl)\npublic Lock lock(String resource, int ttl, int timeout)\npublic Lock lock(String[] resources, int ttl)\n</code></pre> <p>Parameters: - <code>resource</code> - Resource identifier to lock - <code>resources</code> - Multiple resources to lock atomically - <code>ttl</code> - Time-to-live in milliseconds - <code>timeout</code> - Maximum time to wait for lock acquisition (optional)</p> <p>Returns: - <code>Lock</code> object if successful, <code>null</code> if failed</p> <p>Example: <pre><code>Lock lock = redlock.lock(\"my-resource\", 10000);\n</code></pre></p>"},{"location":"api/core/#trylock","title":"tryLock()","text":"<p>Attempt to acquire a lock without retries.</p> <pre><code>public Lock tryLock(String resource, int ttl)\n</code></pre> <p>Parameters: - <code>resource</code> - Resource identifier to lock - <code>ttl</code> - Time-to-live in milliseconds</p> <p>Returns: - <code>Lock</code> object if successful, <code>null</code> if failed</p> <p>Example: <pre><code>Lock lock = redlock.tryLock(\"my-resource\", 10000);\n</code></pre></p>"},{"location":"api/core/#unlock","title":"unlock()","text":"<p>Release a previously acquired lock.</p> <pre><code>public void unlock(Lock lock)\n</code></pre> <p>Parameters: - <code>lock</code> - Lock object to release</p> <p>Example: <pre><code>redlock.unlock(lock);\n</code></pre></p>"},{"location":"api/core/#extend","title":"extend()","text":"<p>Extend the TTL of an existing lock.</p> <pre><code>public boolean extend(Lock lock, int additionalTtl)\n</code></pre> <p>Parameters: - <code>lock</code> - Lock to extend - <code>additionalTtl</code> - Additional time in milliseconds</p> <p>Returns: - <code>true</code> if extension successful, <code>false</code> otherwise</p> <p>Example: <pre><code>boolean extended = redlock.extend(lock, 5000);\n</code></pre></p>"},{"location":"api/core/#isvalid","title":"isValid()","text":"<p>Check if a lock is still valid.</p> <pre><code>public boolean isValid(Lock lock)\n</code></pre> <p>Parameters: - <code>lock</code> - Lock to check</p> <p>Returns: - <code>true</code> if lock is still valid, <code>false</code> otherwise</p> <p>Example: <pre><code>if (redlock.isValid(lock)) {\n    // Lock is still valid\n}\n</code></pre></p>"},{"location":"api/core/#lock-interface","title":"Lock Interface","text":"<p>Represents a distributed lock.</p>"},{"location":"api/core/#methods","title":"Methods","text":"<pre><code>public String getResource()\npublic String getValue()\npublic long getValidityTime()\n</code></pre> <p>Example: <pre><code>Lock lock = redlock.lock(\"resource\", 10000);\nString resource = lock.getResource();  // \"resource\"\nString value = lock.getValue();        // Unique lock value\nlong validity = lock.getValidityTime(); // Remaining validity in ms\n</code></pre></p>"},{"location":"api/core/#redlockconfiguration-class","title":"RedlockConfiguration Class","text":"<p>Configuration for Redlock behavior.</p>"},{"location":"api/core/#builder","title":"Builder","text":"<pre><code>RedlockConfiguration config = RedlockConfiguration.builder()\n    .retryCount(3)\n    .retryDelay(200)\n    .clockDriftFactor(0.01)\n    .build();\n</code></pre>"},{"location":"api/core/#properties","title":"Properties","text":"Property Type Default Description <code>retryCount</code> int 3 Number of retry attempts <code>retryDelay</code> int 200 Delay between retries (ms) <code>clockDriftFactor</code> double 0.01 Clock drift compensation factor <p>Example: <pre><code>RedlockConfiguration config = RedlockConfiguration.builder()\n    .retryCount(5)\n    .retryDelay(100)\n    .clockDriftFactor(0.02)\n    .build();\n\nRedlock redlock = new Redlock(config, pool1, pool2, pool3);\n</code></pre></p>"},{"location":"api/core/#exceptions","title":"Exceptions","text":""},{"location":"api/core/#redlockexception","title":"RedlockException","text":"<p>Base exception for Redlock operations.</p> <pre><code>try {\n    Lock lock = redlock.lock(\"resource\", 10000);\n} catch (RedlockException e) {\n    logger.error(\"Redlock error\", e);\n}\n</code></pre>"},{"location":"api/core/#lockacquisitionexception","title":"LockAcquisitionException","text":"<p>Thrown when lock acquisition fails critically.</p> <pre><code>try {\n    Lock lock = redlock.lock(\"resource\", 10000);\n} catch (LockAcquisitionException e) {\n    logger.error(\"Failed to acquire lock\", e);\n}\n</code></pre>"},{"location":"api/core/#thread-safety","title":"Thread Safety","text":"<p>All Redlock methods are thread-safe and can be called concurrently from multiple threads.</p> <pre><code>// Safe to use from multiple threads\nRedlock redlock = new Redlock(pool1, pool2, pool3);\n\n// Thread 1\nLock lock1 = redlock.lock(\"resource-1\", 10000);\n\n// Thread 2 (concurrent)\nLock lock2 = redlock.lock(\"resource-2\", 10000);\n</code></pre>"},{"location":"api/core/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration API - Configuration details</li> <li>Basic Usage - Usage examples</li> </ul>"},{"location":"comparison/countdownlatch-implementation/","title":"CountDownLatch Implementation Comparison: redlock4j vs Redisson","text":"<p>This document provides a detailed technical comparison of the CountDownLatch implementations in redlock4j and Redisson.</p>"},{"location":"comparison/countdownlatch-implementation/#overview","title":"Overview","text":"<p>Both libraries implement distributed countdown latches for coordinating multiple threads/processes, but they use different approaches for counting and notification.</p>"},{"location":"comparison/countdownlatch-implementation/#purpose-use-case","title":"Purpose &amp; Use Case","text":""},{"location":"comparison/countdownlatch-implementation/#redlock4j-redlockcountdownlatch","title":"redlock4j RedlockCountDownLatch","text":"<p>Purpose: Distributed countdown latch with quorum-based consistency</p> <p>Use Case: Coordinating distributed processes with strong consistency requirements</p> <pre><code>// Create latch waiting for 3 operations\nRedlockCountDownLatch latch = new RedlockCountDownLatch(\n    \"startup\", 3, redisDrivers, config\n);\n\n// Worker threads\nnew Thread(() -&gt; {\n    initializeService1();\n    latch.countDown();\n}).start();\n\nnew Thread(() -&gt; {\n    initializeService2();\n    latch.countDown();\n}).start();\n\nnew Thread(() -&gt; {\n    initializeService3();\n    latch.countDown();\n}).start();\n\n// Main thread waits\nlatch.await(); // Blocks until count reaches 0\nSystem.out.println(\"All services initialized!\");\n</code></pre>"},{"location":"comparison/countdownlatch-implementation/#redisson-redissoncountdownlatch","title":"Redisson RedissonCountDownLatch","text":"<p>Purpose: Distributed countdown latch with pub/sub notifications</p> <p>Use Case: High-performance coordination with single Redis instance</p> <pre><code>RCountDownLatch latch = redisson.getCountDownLatch(\"startup\");\nlatch.trySetCount(3);\n\n// Worker threads\nnew Thread(() -&gt; {\n    initializeService1();\n    latch.countDown();\n}).start();\n\n// ... more workers\n\n// Main thread waits\nlatch.await();\nSystem.out.println(\"All services initialized!\");\n</code></pre>"},{"location":"comparison/countdownlatch-implementation/#architecture-data-model","title":"Architecture &amp; Data Model","text":""},{"location":"comparison/countdownlatch-implementation/#redlock4j","title":"redlock4j","text":"<p>Design: Counter with quorum-based reads/writes and pub/sub</p> <p>Data Structure: <pre><code>{latchKey} = {count}                    (counter on each node)\n{latchKey}:channel = (pub/sub channel)  (notification channel)\n</code></pre></p> <p>Key Characteristics: - Counter replicated across all nodes - Quorum-based count reads - Quorum-based decrements - Pub/sub for zero notification - Local latch for waiting - Automatic expiration (10x lock timeout)</p> <p>Architecture: <pre><code>RedlockCountDownLatch\n  \u251c\u2500 latchKey (counter key)\n  \u251c\u2500 channelKey (pub/sub)\n  \u251c\u2500 List&lt;RedisDriver&gt; (quorum-based)\n  \u251c\u2500 CountDownLatch localLatch (for waiting)\n  \u251c\u2500 AtomicBoolean subscribed\n  \u2514\u2500 Quorum-based DECR\n</code></pre></p>"},{"location":"comparison/countdownlatch-implementation/#redisson","title":"Redisson","text":"<p>Design: Single counter with pub/sub and Lua scripts</p> <p>Data Structure: <pre><code>{latchKey} = {count}                                    (single counter)\nredisson_countdownlatch__channel__{latchKey} = (pub/sub channel)\n</code></pre></p> <p>Key Characteristics: - Single counter (not replicated) - Atomic Lua scripts - Pub/sub for notifications - Async/reactive support - No automatic expiration</p> <p>Architecture: <pre><code>RedissonCountDownLatch\n  \u251c\u2500 latchKey (counter key)\n  \u251c\u2500 channelName (pub/sub)\n  \u251c\u2500 CountDownLatchPubSub (notification handler)\n  \u251c\u2500 Lua scripts for atomicity\n  \u2514\u2500 Async futures\n</code></pre></p>"},{"location":"comparison/countdownlatch-implementation/#initialization","title":"Initialization","text":""},{"location":"comparison/countdownlatch-implementation/#redlock4j_1","title":"redlock4j","text":"<p>Initialization: Automatic in constructor</p> <pre><code>public RedlockCountDownLatch(String latchKey, int count,\n                             List&lt;RedisDriver&gt; redisDrivers,\n                             RedlockConfiguration config) {\n    this.latchKey = latchKey;\n    this.channelKey = latchKey + \":channel\";\n    this.initialCount = count;\n    this.localLatch = new CountDownLatch(1);\n\n    // Initialize on all nodes\n    initializeLatch(count);\n}\n\nprivate void initializeLatch(int count) {\n    String countValue = String.valueOf(count);\n    int successfulNodes = 0;\n\n    for (RedisDriver driver : redisDrivers) {\n        // Set with long expiration (10x lock timeout)\n        driver.setex(latchKey, countValue,\n\n\n## Count Down Operation\n\n### redlock4j\n\n**Algorithm**: Quorum-based DECR with notification\n\n```java\npublic void countDown() {\n    int successfulNodes = 0;\n    long newCount = -1;\n\n    // Decrement on all nodes\n    for (RedisDriver driver : redisDrivers) {\n        try {\n            long count = driver.decr(latchKey);\n            newCount = count;\n            successfulNodes++;\n        } catch (Exception e) {\n            logger.debug(\"Failed to decrement on {}\", driver.getIdentifier());\n        }\n    }\n\n    // Check quorum\n    if (successfulNodes &gt;= config.getQuorum()) {\n        // If reached zero, publish notification\n        if (newCount &lt;= 0) {\n            publishZeroNotification();\n        }\n    } else {\n        logger.warn(\"Failed to decrement on quorum\");\n    }\n}\n\nprivate void publishZeroNotification() {\n    for (RedisDriver driver : redisDrivers) {\n        try {\n            long subscribers = driver.publish(channelKey, \"zero\");\n            logger.debug(\"Published to {} subscribers\", subscribers);\n        } catch (Exception e) {\n            logger.debug(\"Failed to publish on {}\", driver.getIdentifier());\n        }\n    }\n}\n</code></pre> <p>Characteristics: - DECR on all nodes - Quorum check for success - Publish to all nodes when zero - No atomicity between decrement and publish</p> <p>Redis Operations (M nodes): - M \u00d7 <code>DECR</code> - M \u00d7 <code>PUBLISH</code> (if zero)</p>"},{"location":"comparison/countdownlatch-implementation/#redisson_1","title":"Redisson","text":"<p>Algorithm: Atomic Lua script with notification</p> <pre><code>-- countDownAsync\nlocal v = redis.call('decr', KEYS[1]);\nif v &lt;= 0 then\n    redis.call('del', KEYS[1])\nend;\nif v == 0 then\n    redis.call(ARGV[2], KEYS[2], ARGV[1])\nend;\n</code></pre> <p>Characteristics: - Atomic decrement + delete + publish - Single operation - Deletes key when zero - Publishes ZERO_COUNT_MESSAGE</p> <p>Redis Operations: - 1 Lua script execution</p>"},{"location":"comparison/countdownlatch-implementation/#await-operation","title":"Await Operation","text":""},{"location":"comparison/countdownlatch-implementation/#redlock4j_2","title":"redlock4j","text":"<p>Algorithm: Subscribe + poll with local latch</p> <pre><code>public boolean await(long timeout, TimeUnit unit) throws InterruptedException {\n    // Subscribe to notifications\n    subscribeToNotifications();\n\n    // Check if already zero\n    long currentCount = getCount();\n    if (currentCount &lt;= 0) {\n        return true;\n    }\n\n    // Wait on local latch (released by pub/sub notification)\n    boolean completed = localLatch.await(timeout, unit);\n\n    return completed;\n}\n\nprivate void subscribeToNotifications() {\n    if (subscribed.compareAndSet(false, true)) {\n        new Thread(() -&gt; {\n            // Subscribe to first driver\n            RedisDriver driver = redisDrivers.get(0);\n            driver.subscribe(new MessageHandler() {\n                @Override\n                public void onMessage(String channel, String message) {\n                    if (\"zero\".equals(message)) {\n                        localLatch.countDown(); // Release waiters\n                    }\n                }\n            }, channelKey);\n        }).start();\n    }\n}\n\npublic long getCount() {\n    int successfulReads = 0;\n    long totalCount = 0;\n\n    for (RedisDriver driver : redisDrivers) {\n        String countStr = driver.get(latchKey);\n        if (countStr != null) {\n            totalCount += Long.parseLong(countStr);\n            successfulReads++;\n        }\n    }\n\n    if (successfulReads &gt;= config.getQuorum()) {\n        return Math.max(0, totalCount / successfulReads);\n    }\n\n    return 0; // Conservative fallback\n}\n</code></pre> <p>Characteristics: - Subscribe to single driver (first one) - Check count via quorum read - Wait on local CountDownLatch - Pub/sub releases local latch - Average count across nodes</p> <p>Redis Operations (M nodes): - 1 \u00d7 <code>SUBSCRIBE</code> - M \u00d7 <code>GET</code> (check count)</p>"},{"location":"comparison/countdownlatch-implementation/#redisson_2","title":"Redisson","text":"<p>Algorithm: Subscribe + async polling</p> <pre><code>public void await() throws InterruptedException {\n    if (getCount() == 0) {\n        return;\n    }\n\n    CompletableFuture&lt;RedissonCountDownLatchEntry&gt; future = subscribe();\n    RedissonCountDownLatchEntry entry = future.join();\n\n    try {\n        while (getCount() &gt; 0) {\n            entry.getLatch().await(); // Wait for notification\n        }\n    } finally {\n        unsubscribe(entry);\n    }\n}\n\nprivate CompletableFuture&lt;RedissonCountDownLatchEntry&gt; subscribe() {\n    return pubSub.subscribe(getEntryName(), getChannelName());\n}\n\npublic long getCount() {\n    return commandExecutor.writeAsync(\n        getRawName(), LongCodec.INSTANCE,\n        RedisCommands.GET_LONG, getRawName()\n    ).join();\n}\n</code></pre> <p>Characteristics: - Subscribe via pub/sub service - Poll count in loop - Semaphore-based waiting - Async futures - Unsubscribe when done</p> <p>Redis Operations: - 1 \u00d7 <code>SUBSCRIBE</code> - N \u00d7 <code>GET</code> (polling)</p>"},{"location":"comparison/countdownlatch-implementation/#reset-operation","title":"Reset Operation","text":""},{"location":"comparison/countdownlatch-implementation/#redlock4j_3","title":"redlock4j","text":"<p>Reset: Supported (non-standard)</p> <pre><code>public void reset() {\n    // Delete existing latch\n    for (RedisDriver driver : redisDrivers) {\n        driver.del(latchKey);\n    }\n\n    // Reset local state\n    localLatch = new CountDownLatch(1);\n    subscribed.set(false);\n\n    // Reinitialize\n    initializeLatch(initialCount);\n}\n</code></pre> <p>Characteristics: - Deletes on all nodes - Resets local latch - Reinitializes with original count - Not atomic - Can cause race conditions</p>"},{"location":"comparison/countdownlatch-implementation/#redisson_3","title":"Redisson","text":"<p>Reset: Supported via <code>trySetCount()</code></p> <pre><code>// Delete old latch\nlatch.delete();\n\n// Create new one\nlatch.trySetCount(initialCount);\n</code></pre> <p>Characteristics: - Must explicitly delete first - Then set new count - Two separate operations - Not atomic - Publishes notifications</p>"},{"location":"comparison/countdownlatch-implementation/#performance-comparison","title":"Performance Comparison","text":""},{"location":"comparison/countdownlatch-implementation/#redlock4j_4","title":"redlock4j","text":"<p>Count Down (M nodes): - M \u00d7 <code>DECR</code> - M \u00d7 <code>PUBLISH</code> (if zero) - Total: M or 2M operations</p> <p>Await: - 1 \u00d7 <code>SUBSCRIBE</code> - M \u00d7 <code>GET</code> (quorum read) - Total: M+1 operations</p> <p>Complexity: O(M) per operation</p> <p>Latency: - Higher due to quorum - Multiple round trips - Pub/sub to all nodes</p>"},{"location":"comparison/countdownlatch-implementation/#redisson_4","title":"Redisson","text":"<p>Count Down: - 1 Lua script execution - Total: 1 operation</p> <p>Await: - 1 \u00d7 <code>SUBSCRIBE</code> - N \u00d7 <code>GET</code> (polling) - Total: N+1 operations</p> <p>Complexity: O(1) for countDown, O(N) for await</p> <p>Latency: - Lower for single instance - Single round trip for countDown - Polling overhead for await</p>"},{"location":"comparison/countdownlatch-implementation/#safety-correctness","title":"Safety &amp; Correctness","text":""},{"location":"comparison/countdownlatch-implementation/#redlock4j_5","title":"redlock4j","text":"<p>Safety Guarantees: - \u2705 Quorum-based consistency - \u2705 Survives minority node failures - \u2705 Count averaged across nodes - \u2705 Automatic expiration - \u2705 No single point of failure</p> <p>Potential Issues: - \u26a0\ufe0f Higher latency - \u26a0\ufe0f More network overhead - \u26a0\ufe0f Non-atomic decrement + publish - \u26a0\ufe0f Subscribe to single node only - \u26a0\ufe0f Count averaging may be inaccurate - \u26a0\ufe0f Reset not atomic</p> <p>Consistency Model: <pre><code>Count decremented if:\n  - Quorum of nodes decremented\n  - Average count used for reads\n\nNotification sent if:\n  - Any node reaches zero\n  - Published to all nodes\n</code></pre></p>"},{"location":"comparison/countdownlatch-implementation/#redisson_5","title":"Redisson","text":"<p>Safety Guarantees: - \u2705 Atomic operations (Lua scripts) - \u2705 Accurate count - \u2705 Pub/sub notifications - \u2705 Async/reactive support - \u2705 Low latency</p> <p>Potential Issues: - \u26a0\ufe0f Single point of failure - \u26a0\ufe0f No quorum mechanism - \u26a0\ufe0f No automatic expiration - \u26a0\ufe0f Polling in await loop - \u26a0\ufe0f Reset not atomic</p> <p>Consistency Model: <pre><code>Count decremented if:\n  - Atomic Lua script succeeds\n  - Single instance\n\nNotification sent if:\n  - Count reaches exactly zero\n  - Atomic with decrement\n</code></pre></p>"},{"location":"comparison/countdownlatch-implementation/#feature-comparison-table","title":"Feature Comparison Table","text":"Feature redlock4j Redisson Data Model Counter on all nodes Single counter Quorum Yes No Fault Tolerance Survives minority failures Single point of failure Initialization Automatic in constructor Explicit via trySetCount() Expiration Automatic (10x timeout) No automatic expiration Count Accuracy Average across nodes Exact Atomicity Non-atomic (DECR + PUBLISH) Atomic (Lua script) Subscription Single node Managed pub/sub service Reset Supported (non-standard) Supported via delete + trySetCount Async Support No Yes Reactive Support No Yes Performance O(M) O(1) for countDown Latency Higher Lower Network Overhead High Low"},{"location":"comparison/countdownlatch-implementation/#use-case-comparison","title":"Use Case Comparison","text":""},{"location":"comparison/countdownlatch-implementation/#redlock4j-redlockcountdownlatch_1","title":"redlock4j RedlockCountDownLatch","text":"<p>Best For: - Distributed systems requiring quorum-based safety - Coordination with strong consistency - Multi-master Redis setups - Fault-tolerant coordination - Automatic expiration needed</p> <p>Example Scenarios: <pre><code>// Distributed service startup coordination\nRedlockCountDownLatch startupLatch = new RedlockCountDownLatch(\n    \"app:startup\", 5, redisDrivers, config\n);\n\n// Batch job coordination\nRedlockCountDownLatch batchLatch = new RedlockCountDownLatch(\n    \"batch:job:123\", 100, redisDrivers, config\n);\n\n// Multi-stage workflow\nRedlockCountDownLatch stageLatch = new RedlockCountDownLatch(\n    \"workflow:stage1\", 10, redisDrivers, config\n);\n</code></pre></p>"},{"location":"comparison/countdownlatch-implementation/#redisson-redissoncountdownlatch_1","title":"Redisson RedissonCountDownLatch","text":"<p>Best For: - Single Redis instance deployments - High-throughput coordination - Applications needing async/reactive APIs - Scenarios requiring exact count - Low-latency requirements</p> <p>Example Scenarios: <pre><code>// High-performance service coordination\nRCountDownLatch startupLatch = redisson.getCountDownLatch(\"app:startup\");\nstartupLatch.trySetCount(5);\n\n// Async coordination\nRCountDownLatch asyncLatch = redisson.getCountDownLatch(\"async:task\");\nasyncLatch.trySetCount(10);\nRFuture&lt;Void&gt; future = asyncLatch.awaitAsync();\n\n// Reusable latch\nRCountDownLatch reusableLatch = redisson.getCountDownLatch(\"reusable\");\nreusableLatch.trySetCount(3);\n// ... use it\nreusableLatch.delete();\nreusableLatch.trySetCount(5); // Reuse\n</code></pre></p>"},{"location":"comparison/countdownlatch-implementation/#recommendations","title":"Recommendations","text":""},{"location":"comparison/countdownlatch-implementation/#choose-redlock4j-redlockcountdownlatch-when","title":"Choose redlock4j RedlockCountDownLatch when:","text":"<ul> <li>\u2705 Need quorum-based distributed consistency</li> <li>\u2705 Require fault tolerance (multi-master)</li> <li>\u2705 Automatic expiration is important</li> <li>\u2705 Can tolerate higher latency</li> <li>\u2705 Count averaging is acceptable</li> </ul>"},{"location":"comparison/countdownlatch-implementation/#choose-redisson-redissoncountdownlatch-when","title":"Choose Redisson RedissonCountDownLatch when:","text":"<ul> <li>\u2705 Single Redis instance is acceptable</li> <li>\u2705 Need high throughput / low latency</li> <li>\u2705 Require exact count tracking</li> <li>\u2705 Need async/reactive APIs</li> <li>\u2705 Want atomic operations</li> <li>\u2705 Explicit initialization preferred</li> </ul>"},{"location":"comparison/countdownlatch-implementation/#migration-considerations","title":"Migration Considerations","text":""},{"location":"comparison/countdownlatch-implementation/#from-redisson-to-redlock4j","title":"From Redisson to redlock4j","text":"<pre><code>// Before (Redisson)\nRCountDownLatch latch = redisson.getCountDownLatch(\"startup\");\nlatch.trySetCount(3);\nlatch.await();\n\n// After (redlock4j)\nRedlockCountDownLatch latch = new RedlockCountDownLatch(\n    \"startup\", 3, redisDrivers, config\n);\nlatch.await();\n</code></pre> <p>Benefits: - Quorum-based safety - Fault tolerance - Automatic expiration</p> <p>Considerations: - Higher latency - Count is averaged - No async support</p>"},{"location":"comparison/countdownlatch-implementation/#from-redlock4j-to-redisson","title":"From redlock4j to Redisson","text":"<pre><code>// Before (redlock4j)\nRedlockCountDownLatch latch = new RedlockCountDownLatch(\n    \"startup\", 3, redisDrivers, config\n);\n\n// After (Redisson)\nRCountDownLatch latch = redisson.getCountDownLatch(\"startup\");\nlatch.trySetCount(3);\n</code></pre> <p>Benefits: - Lower latency - Exact count - Async/reactive support - Atomic operations</p> <p>Considerations: - Single point of failure - Must initialize explicitly - No automatic expiration</p>"},{"location":"comparison/countdownlatch-implementation/#conclusion","title":"Conclusion","text":"<p>Both implementations provide distributed countdown latches with different trade-offs:</p> <p>redlock4j RedlockCountDownLatch: - Quorum-based with fault tolerance - Automatic initialization and expiration - Higher latency but survives failures - Count averaged across nodes - Best for multi-master setups requiring strong consistency</p> <p>Redisson RedissonCountDownLatch: - Atomic Lua scripts with exact counting - Lower latency but single point of failure - Pub/sub notifications - Async/reactive support - Best for high-throughput single-instance deployments</p> <p>Choose based on your specific requirements: - Distributed consistency &amp; fault tolerance \u2192 redlock4j RedlockCountDownLatch - High throughput &amp; low latency \u2192 Redisson RedissonCountDownLatch - Exact count tracking \u2192 Redisson RedissonCountDownLatch - Automatic expiration \u2192 redlock4j RedlockCountDownLatch</p>"},{"location":"comparison/fairlock-implementation/","title":"FairLock Implementation Comparison: redlock4j vs Redisson","text":"<p>This document provides a detailed technical comparison of the FairLock implementations in redlock4j and Redisson.</p>"},{"location":"comparison/fairlock-implementation/#overview","title":"Overview","text":"<p>Both libraries implement fair locks to ensure FIFO (First-In-First-Out) ordering for lock acquisition, but they use different approaches and data structures.</p>"},{"location":"comparison/fairlock-implementation/#architecture-data-structures","title":"Architecture &amp; Data Structures","text":""},{"location":"comparison/fairlock-implementation/#redlock4j","title":"redlock4j","text":"<ul> <li>Data Structure: Redis Sorted Sets (ZSET) exclusively</li> <li>Keys Used:</li> <li>Lock key: <code>{lockKey}</code></li> <li>Queue key: <code>{lockKey}:queue</code></li> <li>Queue Management: Tokens stored with timestamps as scores</li> <li>Approach: Simpler two-key design</li> </ul>"},{"location":"comparison/fairlock-implementation/#redisson","title":"Redisson","text":"<ul> <li>Data Structures: Redis List (LIST) + Sorted Set (ZSET)</li> <li>Keys Used:</li> <li>Lock key: <code>{lockName}</code></li> <li>Queue key: <code>redisson_lock_queue:{lockName}</code></li> <li>Timeout key: <code>redisson_lock_timeout:{lockName}</code></li> <li>Queue Management: List for ordering, sorted set for timeout tracking</li> <li>Approach: Three-key design with separate timeout management</li> </ul>"},{"location":"comparison/fairlock-implementation/#queue-management-operations","title":"Queue Management Operations","text":""},{"location":"comparison/fairlock-implementation/#redlock4j_1","title":"redlock4j","text":"<pre><code>// Add to queue\ndriver.zAdd(queueKey, timestamp, token)\n\n// Check position\nList&lt;String&gt; first = driver.zRange(queueKey, 0, 0)\nboolean atFront = token.equals(first.get(0))\n\n// Remove from queue\ndriver.zRem(queueKey, token)\n\n// Cleanup expired\ndriver.zRemRangeByScore(queueKey, 0, expirationThreshold)\n</code></pre> <p>Characteristics: - Position determined by timestamp score - Natural ordering by insertion time - Single operation for position check</p>"},{"location":"comparison/fairlock-implementation/#redisson_1","title":"Redisson","text":"<pre><code>-- Add to queue\nredis.call('rpush', KEYS[2], ARGV[2])\nredis.call('zadd', KEYS[3], timeout, ARGV[2])\n\n-- Check position\nlocal firstThreadId = redis.call('lindex', KEYS[2], 0)\n\n-- Remove from queue\nredis.call('lpop', KEYS[2])\nredis.call('zrem', KEYS[3], ARGV[2])\n</code></pre> <p>Characteristics: - Position determined by list insertion order - Separate timeout tracking in sorted set - Two operations required for queue management</p>"},{"location":"comparison/fairlock-implementation/#fairness-guarantee","title":"Fairness Guarantee","text":""},{"location":"comparison/fairlock-implementation/#redlock4j_2","title":"redlock4j","text":"<ul> <li>Ordering: Based on timestamp when added to queue</li> <li>Quorum: Requires majority agreement on queue position</li> <li>Verification: <code>isAtFrontOfQueue()</code> checks across multiple nodes</li> <li>Clock Dependency: Relies on reasonably synchronized clocks</li> </ul> <pre><code>int votesForFront = 0;\nfor (RedisDriver driver : redisDrivers) {\n    List&lt;String&gt; firstElements = driver.zRange(queueKey, 0, 0);\n    if (!firstElements.isEmpty() &amp;&amp; token.equals(firstElements.get(0))) {\n        votesForFront++;\n    }\n}\nreturn votesForFront &gt;= config.getQuorum();\n</code></pre>"},{"location":"comparison/fairlock-implementation/#redisson_2","title":"Redisson","text":"<ul> <li>Ordering: Based on list insertion order (FIFO)</li> <li>Stale Cleanup: Removes expired threads before each operation</li> <li>Timeout Calculation: Dynamic based on queue position</li> <li>Clock Dependency: Uses timeouts but less sensitive to clock skew</li> </ul> <pre><code>-- Cleanup stale threads first\nwhile true do\n    local firstThreadId = redis.call('lindex', KEYS[2], 0)\n    if firstThreadId == false then break end\n    local timeout = redis.call('zscore', KEYS[3], firstThreadId)\n    if timeout ~= false and tonumber(timeout) &lt;= tonumber(ARGV[4]) then\n        redis.call('zrem', KEYS[3], firstThreadId)\n        redis.call('lpop', KEYS[2])\n    else break end\nend\n</code></pre>"},{"location":"comparison/fairlock-implementation/#stale-entry-cleanup","title":"Stale Entry Cleanup","text":""},{"location":"comparison/fairlock-implementation/#redlock4j_3","title":"redlock4j","text":"<p>Strategy: Periodic cleanup during queue operations</p> <pre><code>private void addToQueue(String token, long timestamp) {\n    // Add to queue\n    for (RedisDriver driver : redisDrivers) {\n        driver.zAdd(queueKey, timestamp, token);\n    }\n\n    // Cleanup expired entries\n    long expirationThreshold = System.currentTimeMillis()\n        - config.getDefaultLockTimeoutMs() * 2;\n    cleanupExpiredQueueEntries(expirationThreshold);\n}\n</code></pre> <p>Characteristics: - Cleanup triggered on <code>addToQueue()</code> - Removes entries older than 2x lock timeout - Separate cleanup operation</p>"},{"location":"comparison/fairlock-implementation/#redisson_3","title":"Redisson","text":"<p>Strategy: Cleanup before every lock operation</p> <pre><code>-- Embedded in every Lua script\nwhile true do\n    local firstThreadId = redis.call('lindex', KEYS[2], 0)\n    if firstThreadId == false then break end\n    local timeout = redis.call('zscore', KEYS[3], firstThreadId)\n    if timeout ~= false and tonumber(timeout) &lt;= currentTime then\n        redis.call('zrem', KEYS[3], firstThreadId)\n        redis.call('lpop', KEYS[2])\n    else break end\nend\n</code></pre> <p>Characteristics: - State stored in Redis - Requires Redis call for reentrant check - Survives JVM restart - Consistent across instances</p>"},{"location":"comparison/fairlock-implementation/#lock-acquisition-flow","title":"Lock Acquisition Flow","text":""},{"location":"comparison/fairlock-implementation/#redlock4j_4","title":"redlock4j","text":"<pre><code>public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {\n    // 1. Check for reentrancy (thread-local)\n    LockState currentState = lockState.get();\n    if (currentState != null &amp;&amp; currentState.isValid()) {\n        currentState.incrementHoldCount();\n        return true;\n    }\n\n    // 2. Add to queue with timestamp\n    String queueToken = generateToken();\n    long timestamp = System.currentTimeMillis();\n    addToQueue(queueToken, timestamp);\n\n    // 3. Retry loop\n    for (int attempt = 0; attempt &lt;= maxRetryAttempts; attempt++) {\n        // 4. Check if at front (quorum-based)\n        if (isAtFrontOfQueue(queueToken)) {\n            // 5. Try standard Redlock acquisition\n            LockResult result = attemptLock();\n            if (result.isAcquired()) {\n                lockState.set(new LockState(...));\n                return true;\n            }\n        }\n\n        // 6. Check timeout\n        if (timeoutExceeded) {\n            removeFromQueue(queueToken);\n            break;\n        }\n\n        // 7. Wait and retry\n        Thread.sleep(retryDelayMs);\n    }\n\n    removeFromQueue(queueToken);\n    return false;\n}\n</code></pre> <p>Flow: 1. Check thread-local reentrancy 2. Add to queue with current timestamp 3. Poll until at front of queue (quorum check) 4. Attempt standard Redlock acquisition 5. Remove from queue on success/failure</p>"},{"location":"comparison/fairlock-implementation/#redisson_4","title":"Redisson","text":"<pre><code>-- 1. Clean stale threads\nwhile true do\n    -- Remove expired threads from front\nend\n\n-- 2. Check if lock can be acquired\nif (redis.call('exists', KEYS[1]) == 0)\n    and ((redis.call('exists', KEYS[2]) == 0)\n        or (redis.call('lindex', KEYS[2], 0) == ARGV[2])) then\n\n    -- 3. Remove from queue\n    redis.call('lpop', KEYS[2])\n    redis.call('zrem', KEYS[3], ARGV[2])\n\n    -- 4. Decrease timeouts for remaining waiters\n    local keys = redis.call('zrange', KEYS[3], 0, -1)\n    for i = 1, #keys, 1 do\n        redis.call('zincrby', KEYS[3], -tonumber(ARGV[3]), keys[i])\n    end\n\n    -- 5. Acquire lock\n    redis.call('hset', KEYS[1], ARGV[2], 1)\n    redis.call('pexpire', KEYS[1], ARGV[1])\n    return nil\nend\n\n-- 6. Check for reentrancy\nif redis.call('hexists', KEYS[1], ARGV[2]) == 1 then\n    redis.call('hincrby', KEYS[1], ARGV[2], 1)\n    return nil\nend\n\n-- 7. Add to queue if not present\nlocal timeout = redis.call('zscore', KEYS[3], ARGV[2])\nif timeout == false then\n    -- Calculate timeout based on queue position\n    local lastThreadId = redis.call('lindex', KEYS[2], -1)\n    local ttl = redis.call('pttl', KEYS[1])\n    local timeout = ttl + threadWaitTime + currentTime\n    redis.call('zadd', KEYS[3], timeout, ARGV[2])\n    redis.call('rpush', KEYS[2], ARGV[2])\nend\nreturn ttl\n</code></pre> <p>Flow: 1. Clean stale threads from queue 2. Check if lock is free AND (queue empty OR at front) 3. Remove self from queue 4. Adjust timeouts for remaining threads 5. Acquire lock or return TTL</p>"},{"location":"comparison/fairlock-implementation/#timeout-handling","title":"Timeout Handling","text":""},{"location":"comparison/fairlock-implementation/#redlock4j_5","title":"redlock4j","text":"<p>Strategy: Fixed timeout with retry</p> <pre><code>long timeoutMs = unit.toMillis(time);\nlong startTime = System.currentTimeMillis();\n\nfor (int attempt = 0; attempt &lt;= maxRetryAttempts; attempt++) {\n    // Try to acquire\n\n    if (timeoutMs &gt; 0 &amp;&amp; (System.currentTimeMillis() - startTime) &gt;= timeoutMs) {\n        removeFromQueue(queueToken);\n        break;\n    }\n\n    Thread.sleep(retryDelayMs);\n}\n</code></pre> <p>Characteristics: - Simple timeout check - Fixed retry delay - Client-side timeout management - No timeout estimation</p>"},{"location":"comparison/fairlock-implementation/#redisson_5","title":"Redisson","text":"<p>Strategy: Dynamic timeout calculation</p> <pre><code>-- Calculate timeout based on queue position\nlocal lastThreadId = redis.call('lindex', KEYS[2], -1)\nlocal ttl\nif lastThreadId ~= false and lastThreadId ~= ARGV[2] then\n    ttl = tonumber(redis.call('zscore', KEYS[3], lastThreadId)) - currentTime\nelse\n    ttl = redis.call('pttl', KEYS[1])\nend\nlocal timeout = ttl + threadWaitTime + currentTime\n</code></pre> <p>Characteristics: - Returns estimated wait time (TTL) - Timeout = previous thread timeout + threadWaitTime - Server-side calculation - More accurate wait estimation - Default threadWaitTime: 5 seconds</p>"},{"location":"comparison/fairlock-implementation/#unlock-notification","title":"Unlock &amp; Notification","text":""},{"location":"comparison/fairlock-implementation/#redlock4j_6","title":"redlock4j","text":"<p>Strategy: Simple unlock without notification</p> <pre><code>public void unlock() {\n    LockState state = lockState.get();\n\n    // Handle reentrancy\n    int remainingHolds = state.decrementHoldCount();\n    if (remainingHolds &gt; 0) {\n        return;\n    }\n\n    // Release lock\n    releaseLock(state.lockValue);\n    removeFromQueue(state.queueToken);\n    lockState.remove();\n}\n</code></pre> <p>Characteristics: - No explicit notification to next waiter - Next thread discovers via polling - Simpler implementation - Higher latency for next waiter</p>"},{"location":"comparison/fairlock-implementation/#redisson_6","title":"Redisson","text":"<p>Strategy: Pub/Sub notification to next waiter</p> <pre><code>-- After releasing lock\nredis.call('del', KEYS[1])\nlocal nextThreadId = redis.call('lindex', KEYS[2], 0)\nif nextThreadId ~= false then\n    redis.call('publish', KEYS[4] .. ':' .. nextThreadId, ARGV[1])\nend\n</code></pre> <p>Characteristics: - Explicit wake-up via Redis pub/sub - Next thread notified immediately - Lower latency for next waiter - More complex implementation - Requires pub/sub subscription per thread</p>"},{"location":"comparison/fairlock-implementation/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"comparison/fairlock-implementation/#redlock4j_7","title":"redlock4j","text":"<p>Lines of Code: ~390 lines</p> <p>Pros: - \u2705 Simpler to understand - \u2705 Single data structure (sorted set) - \u2705 Fewer Redis operations - \u2705 Less state to manage - \u2705 Timestamp-based ordering is intuitive</p> <p>Cons: - \u274c Clock skew sensitivity - \u274c Polling-based (no notifications) - \u274c Cleanup only on addToQueue - \u274c Less sophisticated timeout handling</p>"},{"location":"comparison/fairlock-implementation/#redisson_7","title":"Redisson","text":"<p>Lines of Code: ~350 lines (but denser Lua scripts)</p> <p>Pros: - \u2705 Robust stale thread handling - \u2705 Better timeout estimation - \u2705 Explicit thread notification (pub/sub) - \u2705 Less clock-dependent (list ordering) - \u2705 Production-hardened</p> <p>Cons: - \u274c More complex implementation - \u274c Two data structures to maintain - \u274c More Redis operations per attempt - \u274c Cleanup overhead on every operation - \u274c Requires pub/sub infrastructure</p>"},{"location":"comparison/fairlock-implementation/#performance-comparison","title":"Performance Comparison","text":""},{"location":"comparison/fairlock-implementation/#redlock4j_8","title":"redlock4j","text":"<p>Lock Acquisition: - 1x <code>ZADD</code> per node (add to queue) - 1x <code>ZRANGE</code> per node per attempt (check position) - Nx <code>SET NX</code> per node (standard Redlock) - 1x <code>ZREM</code> per node (remove from queue)</p> <p>Unlock: - 1x Lua script per node (delete if matches) - 1x <code>ZREM</code> per node (remove from queue)</p> <p>Total: Moderate Redis operations, polling overhead</p>"},{"location":"comparison/fairlock-implementation/#redisson_8","title":"Redisson","text":"<p>Lock Acquisition: - 1x Lua script (all operations atomic)   - Stale cleanup (variable)   - Queue check   - Lock acquisition   - Timeout updates</p> <p>Unlock: - 1x Lua script   - Stale cleanup   - Lock release   - Pub/sub notification</p> <p>Total: Fewer round trips, but heavier Lua scripts</p>"},{"location":"comparison/fairlock-implementation/#edge-cases-robustness","title":"Edge Cases &amp; Robustness","text":""},{"location":"comparison/fairlock-implementation/#redlock4j_9","title":"redlock4j","text":"<p>Clock Skew: - Timestamps used for ordering - Significant clock skew could affect fairness - Mitigated by clock drift factor in Redlock</p> <p>Stale Entries: - Cleaned up on <code>addToQueue()</code> - Could accumulate between additions - Threshold: 2x lock timeout</p> <p>Network Partitions: - Quorum-based queue position check - Handles minority node failures - Consistent with Redlock guarantees</p>"},{"location":"comparison/fairlock-implementation/#redisson_9","title":"Redisson","text":"<p>Clock Skew: - List ordering independent of clocks - Timeouts use timestamps but less critical - More resilient to clock issues</p> <p>Stale Entries: - Cleaned up on every operation - Only from front of queue - More consistent cleanup</p> <p>Network Partitions: - Single instance by default - No quorum mechanism - Less resilient than redlock4j</p>"},{"location":"comparison/fairlock-implementation/#recommendations","title":"Recommendations","text":""},{"location":"comparison/fairlock-implementation/#for-redlock4j","title":"For redlock4j","text":"<p>Consider Adopting: 1. Pub/Sub Notifications: Reduce polling latency 2. Dynamic Timeout Estimation: Return TTL to caller 3. More Frequent Cleanup: Clean on every operation 4. List-Based Ordering: Reduce clock dependency</p> <p>Keep: 1. Quorum-based queue position check 2. Thread-local state for performance 3. Simple two-key design 4. Standard Redlock integration</p>"},{"location":"comparison/fairlock-implementation/#for-production-use","title":"For Production Use","text":"<p>Choose redlock4j when: - True distributed locking is required - Simplicity and maintainability matter - Quorum-based safety is essential - Minimal dependencies preferred</p> <p>Choose Redisson when: - Single instance is acceptable - Need full Redis framework - Pub/Sub infrastructure available - Production-hardened solution needed</p>"},{"location":"comparison/fairlock-implementation/#conclusion","title":"Conclusion","text":"<p>Both implementations provide fair locking with different trade-offs:</p> <ul> <li>redlock4j: Simpler, quorum-based, timestamp-ordered, polling-based</li> <li>Redisson: Complex, single-instance, list-ordered, notification-based</li> </ul> <p>The choice depends on your specific requirements for safety, performance, and operational complexity.</p> <p>Characteristics: - Cleanup on every lock attempt - Only removes from front of queue - Integrated into lock acquisition logic - Higher overhead but more consistent</p>"},{"location":"comparison/fairlock-implementation/#reentrancy-handling","title":"Reentrancy Handling","text":""},{"location":"comparison/fairlock-implementation/#redlock4j_10","title":"redlock4j","text":"<p>Storage: Thread-local state</p> <pre><code>private final ThreadLocal&lt;LockState&gt; lockState = new ThreadLocal&lt;&gt;();\n\nprivate static class LockState {\n    final String lockValue;\n    final String queueToken;\n    final long acquisitionTime;\n    final long validityTime;\n    int holdCount;\n}\n\n// On reentrant lock\nLockState currentState = lockState.get();\nif (currentState != null &amp;&amp; currentState.isValid()) {\n    currentState.incrementHoldCount();\n    return true;\n}\n</code></pre> <p>Characteristics: - State stored in JVM memory - Fast access (no Redis call) - Per-thread tracking - Lost on JVM restart</p>"},{"location":"comparison/fairlock-implementation/#redisson_10","title":"Redisson","text":"<p>Storage: Redis hash field</p> <pre><code>-- Check for reentrant lock\nif redis.call('hexists', KEYS[1], ARGV[2]) == 1 then\n    redis.call('hincrby', KEYS[1], ARGV[2], 1)\n    redis.call('pexpire', KEYS[1], ARGV[1])\n    return nil\nend\n</code></pre>"},{"location":"comparison/multilock-implementation/","title":"MultiLock Implementation Comparison: redlock4j vs Redisson","text":"<p>This document provides a detailed technical comparison of the MultiLock implementations in redlock4j and Redisson.</p>"},{"location":"comparison/multilock-implementation/#overview","title":"Overview","text":"<p>Both libraries implement multi-lock functionality to atomically acquire multiple locks, but they use fundamentally different approaches and have different design goals.</p>"},{"location":"comparison/multilock-implementation/#purpose-use-case","title":"Purpose &amp; Use Case","text":""},{"location":"comparison/multilock-implementation/#redlock4j-multilock","title":"redlock4j MultiLock","text":"<p>Purpose: Atomic acquisition of multiple independent resources with deadlock prevention</p> <p>Use Case: When you need to lock multiple resources simultaneously (e.g., transferring between multiple bank accounts)</p> <pre><code>MultiLock multiLock = new MultiLock(\n    Arrays.asList(\"account:1\", \"account:2\", \"account:3\"),\n    redisDrivers,\n    config\n);\nmultiLock.lock();\ntry {\n    // All three accounts are now locked\n    transferBetweenAccounts();\n} finally {\n    multiLock.unlock();\n}\n</code></pre>"},{"location":"comparison/multilock-implementation/#redisson-redissonmultilock","title":"Redisson RedissonMultiLock","text":"<p>Purpose: Group multiple RLock objects and manage them as a single lock</p> <p>Use Case: When you have multiple independent locks (possibly from different Redisson instances) that need to be acquired together</p> <pre><code>RLock lock1 = redisson1.getLock(\"lock1\");\nRLock lock2 = redisson2.getLock(\"lock2\");\nRLock lock3 = redisson3.getLock(\"lock3\");\n\nRedissonMultiLock multiLock = new RedissonMultiLock(lock1, lock2, lock3);\nmultiLock.lock();\ntry {\n    // All locks acquired\n} finally {\n    multiLock.unlock();\n}\n</code></pre>"},{"location":"comparison/multilock-implementation/#architecture-design-philosophy","title":"Architecture &amp; Design Philosophy","text":""},{"location":"comparison/multilock-implementation/#redlock4j","title":"redlock4j","text":"<p>Design: Integrated Redlock implementation for multiple resources</p> <p>Key Characteristics: - Each resource is a separate key on the same Redis cluster - Uses the same Redlock quorum mechanism for all resources - Sorted keys to prevent deadlocks - All-or-nothing acquisition with automatic rollback</p> <p>Architecture: <pre><code>MultiLock\n  \u251c\u2500 List&lt;String&gt; lockKeys (sorted)\n  \u251c\u2500 List&lt;RedisDriver&gt; redisDrivers (shared cluster)\n  \u251c\u2500 Quorum-based acquisition per resource\n  \u2514\u2500 Thread-local state tracking\n</code></pre></p>"},{"location":"comparison/multilock-implementation/#redisson","title":"Redisson","text":"<p>Design: Wrapper around multiple independent RLock objects</p> <p>Key Characteristics: - Each RLock can be from a different Redisson instance - Each lock uses its own Redis connection/cluster - No inherent deadlock prevention (no key sorting) - Sequential acquisition with retry logic</p> <p>Architecture: <pre><code>RedissonMultiLock\n  \u251c\u2500 List&lt;RLock&gt; locks (order preserved)\n  \u251c\u2500 Each RLock has its own connection\n  \u251c\u2500 Sequential acquisition\n  \u2514\u2500 Configurable failure tolerance\n</code></pre></p>"},{"location":"comparison/multilock-implementation/#deadlock-prevention","title":"Deadlock Prevention","text":""},{"location":"comparison/multilock-implementation/#redlock4j_1","title":"redlock4j","text":"<p>Strategy: Automatic key sorting</p> <pre><code>// Constructor automatically sorts keys\nthis.lockKeys = lockKeys.stream()\n    .distinct()\n    .sorted()  // Lexicographic ordering\n    .collect(Collectors.toList());\n</code></pre> <p>Guarantee: All threads acquire locks in the same order, preventing circular wait conditions</p> <p>Example: <pre><code>// Thread 1: locks [\"account:1\", \"account:2\", \"account:3\"]\n// Thread 2: locks [\"account:3\", \"account:1\", \"account:2\"]\n// Both will acquire in order: account:1 \u2192 account:2 \u2192 account:3\n</code></pre></p>"},{"location":"comparison/multilock-implementation/#redisson_1","title":"Redisson","text":"<p>Strategy: No automatic deadlock prevention</p> <pre><code>// Locks are acquired in the order provided\npublic RedissonMultiLock(RLock... locks) {\n    this.locks.addAll(Arrays.asList(locks));\n}\n</code></pre> <p>Risk: Developer must ensure consistent ordering</p> <p>Example: <pre><code>// Thread 1: new RedissonMultiLock(lock1, lock2, lock3)\n// Thread 2: new RedissonMultiLock(lock3, lock1, lock2)\n// DEADLOCK POSSIBLE if not careful!\n</code></pre></p>"},{"location":"comparison/multilock-implementation/#lock-acquisition-algorithm","title":"Lock Acquisition Algorithm","text":""},{"location":"comparison/multilock-implementation/#redlock4j_2","title":"redlock4j","text":"<p>Algorithm: Quorum-based atomic acquisition</p> <pre><code>private MultiLockResult attemptMultiLock() {\n    Map&lt;String, String&gt; lockValues = new HashMap&lt;&gt;();\n\n    // 1. Generate unique values for each key\n    for (String key : lockKeys) {\n        lockValues.put(key, generateLockValue());\n    }\n\n    // 2. Try to acquire ALL locks on EACH Redis node\n    int successfulNodes = 0;\n    for (RedisDriver driver : redisDrivers) {\n        if (acquireAllOnNode(driver, lockValues)) {\n            successfulNodes++;\n        }\n    }\n\n    // 3. Check quorum and validity\n    boolean acquired = successfulNodes &gt;= config.getQuorum()\n                    &amp;&amp; validityTime &gt; 0;\n\n    // 4. Rollback if failed\n    if (!acquired) {\n        releaseAllLocks(lockValues);\n    }\n\n    return new MultiLockResult(acquired, validityTime, lockValues, ...);\n}\n</code></pre> <p>Per-Node Acquisition: <pre><code>private boolean acquireAllOnNode(RedisDriver driver, Map&lt;String, String&gt; lockValues) {\n    List&lt;String&gt; acquiredKeys = new ArrayList&lt;&gt;();\n\n    for (String key : lockKeys) {\n        if (driver.setIfNotExists(key, lockValue, timeout)) {\n            acquiredKeys.add(key);\n        } else {\n            // Failed - rollback this node\n            rollbackOnNode(driver, lockValues, acquiredKeys);\n            return false;\n        }\n    }\n    return true;\n}\n</code></pre></p> <p>Flow: 1. Generate unique lock values for all keys 2. For each Redis node:    - Try to acquire ALL locks    - If any fails, rollback that node 3. Check if quorum achieved 4. If not, release all acquired locks</p>"},{"location":"comparison/multilock-implementation/#redisson_2","title":"Redisson","text":"<p>Algorithm: Sequential acquisition with retry and failure tolerance</p> <pre><code>public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) {\n    long remainTime = unit.toMillis(waitTime);\n    long lockWaitTime = calcLockWaitTime(remainTime);\n\n    int failedLocksLimit = failedLocksLimit(); // Default: 0\n    List&lt;RLock&gt; acquiredLocks = new ArrayList&lt;&gt;();\n\n    // 1. Iterate through locks sequentially\n    for (ListIterator&lt;RLock&gt; iterator = locks.listIterator(); iterator.hasNext();) {\n        RLock lock = iterator.next();\n        boolean lockAcquired;\n\n        try {\n            // 2. Try to acquire this lock\n            long awaitTime = Math.min(lockWaitTime, remainTime);\n            lockAcquired = lock.tryLock(awaitTime, newLeaseTime, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            lockAcquired = false;\n        }\n\n        if (lockAcquired) {\n            acquiredLocks.add(lock);\n        } else {\n            // 3. Check if we can tolerate this failure\n            if (locks.size() - acquiredLocks.size() == failedLocksLimit()) {\n                break; // Acquired enough\n            }\n\n            // 4. If no tolerance, retry from beginning\n            if (failedLocksLimit == 0) {\n                unlockInner(acquiredLocks);\n                if (waitTime &lt;= 0) {\n                    return false;\n                }\n                // Reset and retry\n                acquiredLocks.clear();\n                while (iterator.hasPrevious()) {\n                    iterator.previous();\n                }\n            } else {\n                failedLocksLimit--;\n            }\n        }\n\n        // 5. Check timeout\n        if (remainTime &gt; 0) {\n            remainTime -= elapsed;\n            if (remainTime &lt;= 0) {\n                unlockInner(acquiredLocks);\n                return false;\n            }\n        }\n    }\n\n    // 6. Set lease time on all acquired locks\n    if (leaseTime &gt; 0) {\n        acquiredLocks.stream()\n            .map(l -&gt; (RedissonBaseLock) l)\n            .map(l -&gt; l.expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS))\n            .forEach(f -&gt; f.toCompletableFuture().join());\n    }\n\n    return true;\n}\n</code></pre> <p>Flow: 1. Iterate through locks in provided order 2. Try to acquire each lock individually 3. If failure and no tolerance: unlock all and retry from start 4. If failure with tolerance: continue to next lock 5. Check timeout after each attempt 6. Set lease time on all acquired locks</p>"},{"location":"comparison/multilock-implementation/#failure-handling-rollback","title":"Failure Handling &amp; Rollback","text":""},{"location":"comparison/multilock-implementation/#redlock4j_3","title":"redlock4j","text":"<p>Strategy: Per-node rollback with all-or-nothing semantics</p> <pre><code>private void rollbackOnNode(RedisDriver driver, Map&lt;String, String&gt; lockValues,\n                           List&lt;String&gt; acquiredKeys) {\n    for (String key : acquiredKeys) {\n        try {\n            driver.deleteIfValueMatches(key, lockValues.get(key));\n        } catch (Exception e) {\n            logger.warn(\"Failed to rollback lock {} on {}\", key, driver);\n        }\n    }\n}\n</code></pre> <p>Characteristics: - Immediate rollback on any failure within a node - All-or-nothing per node - Quorum check after all nodes attempted - Global rollback if quorum not achieved</p> <p>Example: <pre><code>Node 1: account:1 \u2713, account:2 \u2713, account:3 \u2713 \u2192 Success\nNode 2: account:1 \u2713, account:2 \u2717 \u2192 Rollback account:1 on Node 2\nNode 3: account:1 \u2713, account:2 \u2713, account:3 \u2713 \u2192 Success\n\nResult: 2/3 nodes succeeded\nIf quorum=2: SUCCESS\nIf quorum=3: FAIL \u2192 Rollback all nodes\n</code></pre></p>"},{"location":"comparison/multilock-implementation/#redisson_3","title":"Redisson","text":"<p>Strategy: Retry from beginning on failure (default) or tolerance-based</p> <pre><code>protected int failedLocksLimit() {\n    return 0; // No tolerance by default\n}\n</code></pre> <p>Characteristics: - Default: unlock all and retry from start - Can be overridden for failure tolerance - No per-lock rollback - Sequential retry logic</p> <p>Example (default behavior): <pre><code>Attempt 1: lock1 \u2713, lock2 \u2717 \u2192 Unlock lock1, retry\nAttempt 2: lock1 \u2713, lock2 \u2713, lock3 \u2713 \u2192 Success\n</code></pre></p> <p>Example (with tolerance in RedissonRedLock): <pre><code>RedissonRedLock extends RedissonMultiLock {\n    protected int failedLocksLimit() {\n        return locks.size() - minLocksAmount(locks);\n    }\n\n    protected int minLocksAmount(List&lt;RLock&gt; locks) {\n        return locks.size() / 2 + 1; // Quorum\n    }\n}\n\nAttempt: lock1 \u2713, lock2 \u2717, lock3 \u2713 \u2192 Success (2/3 acquired)\n</code></pre></p>"},{"location":"comparison/multilock-implementation/#reentrancy-support","title":"Reentrancy Support","text":""},{"location":"comparison/multilock-implementation/#redlock4j_4","title":"redlock4j","text":"<p>Implementation: Thread-local state with hold count</p> <pre><code>private final ThreadLocal&lt;LockState&gt; lockState = new ThreadLocal&lt;&gt;();\n\nprivate static class LockState {\n    final Map&lt;String, String&gt; lockValues; // All lock values\n    final long acquisitionTime;\n    final long validityTime;\n    int holdCount;\n}\n\npublic boolean tryLock(long time, TimeUnit unit) {\n    // Check reentrancy\n    LockState currentState = lockState.get();\n    if (currentState != null &amp;&amp; currentState.isValid()) {\n        currentState.incrementHoldCount();\n        return true;\n    }\n    // ... acquire logic\n}\n\npublic void unlock() {\n    LockState state = lockState.get();\n    int remainingHolds = state.decrementHoldCount();\n    if (remainingHolds &gt; 0) {\n        return; // Still held\n    }\n    // ... release logic\n}\n</code></pre> <p>Characteristics: - Single hold count for all locks together - Fast (no Redis calls for reentrant acquisition) - Thread-local storage - All locks treated as atomic unit</p>"},{"location":"comparison/multilock-implementation/#redisson_4","title":"Redisson","text":"<p>Implementation: Delegates to individual RLock reentrancy</p> <pre><code>// Each RLock handles its own reentrancy\npublic boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) {\n    for (RLock lock : locks) {\n        // Each lock checks its own hold count in Redis\n        lockAcquired = lock.tryLock(awaitTime, newLeaseTime, TimeUnit.MILLISECONDS);\n    }\n}\n\npublic void unlock() {\n    locks.forEach(Lock::unlock);\n}\n</code></pre> <p>Characteristics: - Each lock maintains its own hold count - Requires Redis calls for each lock - Independent reentrancy per lock - Locks can have different hold counts</p>"},{"location":"comparison/multilock-implementation/#timeout-validity-calculation","title":"Timeout &amp; Validity Calculation","text":""},{"location":"comparison/multilock-implementation/#redlock4j_5","title":"redlock4j","text":"<p>Strategy: Single validity time for all locks</p> <pre><code>long startTime = System.currentTimeMillis();\n\n// Acquire all locks...\n\nlong elapsedTime = System.currentTimeMillis() - startTime;\nlong driftTime = (long) (config.getDefaultLockTimeoutMs() * config.getClockDriftFactor()) + 2;\nlong validityTime = config.getDefaultLockTimeoutMs() - elapsedTime - driftTime;\n\nboolean acquired = successfulNodes &gt;= config.getQuorum() &amp;&amp; validityTime &gt; 0;\n</code></pre> <p>Characteristics: - Single validity calculation for entire multi-lock - Clock drift compensation - All locks expire together - Validity must be positive for success</p>"},{"location":"comparison/multilock-implementation/#redisson_5","title":"Redisson","text":"<p>Strategy: Individual timeout per lock with dynamic wait time</p> <pre><code>long baseWaitTime = locks.size() * 1500; // 1.5s per lock\n\nlong waitTime;\nif (leaseTime &lt;= 0) {\n    waitTime = baseWaitTime;\n} else {\n    waitTime = unit.toMillis(leaseTime);\n    if (waitTime &lt;= baseWaitTime) {\n        waitTime = ThreadLocalRandom.current().nextLong(waitTime/2, waitTime);\n    } else {\n        waitTime = ThreadLocalRandom.current().nextLong(baseWaitTime, waitTime);\n    }\n}\n</code></pre> <p>Characteristics: - Dynamic wait time based on number of locks - Randomization to avoid thundering herd - Each lock can have different lease time - No global validity check</p>"},{"location":"comparison/multilock-implementation/#performance-comparison","title":"Performance Comparison","text":""},{"location":"comparison/multilock-implementation/#redlock4j_6","title":"redlock4j","text":"<p>Lock Acquisition: - For N resources on M nodes:   - N \u00d7 M <code>SET NX</code> operations (parallel per node)   - Rollback: up to N \u00d7 M <code>DELETE</code> operations - Single round of attempts per retry - All nodes contacted in parallel</p> <p>Complexity: O(N \u00d7 M) per attempt</p> <p>Example (3 resources, 3 nodes): <pre><code>Attempt 1:\n  Node 1: SET account:1, SET account:2, SET account:3\n  Node 2: SET account:1, SET account:2, SET account:3\n  Node 3: SET account:1, SET account:2, SET account:3\nTotal: 9 operations (parallel)\n</code></pre></p>"},{"location":"comparison/multilock-implementation/#redisson_6","title":"Redisson","text":"<p>Lock Acquisition: - For N locks:   - N sequential lock attempts   - Each lock may involve multiple Redis operations   - Retry from beginning on failure - Sequential processing</p> <p>Complexity: O(N \u00d7 R) where R = retry attempts</p> <p>Example (3 locks): <pre><code>Attempt 1:\n  lock1.tryLock() \u2192 Redis operations\n  lock2.tryLock() \u2192 Redis operations\n  lock2 fails \u2192 unlock lock1\nAttempt 2:\n  lock1.tryLock() \u2192 Redis operations\n  lock2.tryLock() \u2192 Redis operations\n  lock3.tryLock() \u2192 Redis operations\nTotal: Variable, sequential\n</code></pre></p>"},{"location":"comparison/multilock-implementation/#use-case-differences","title":"Use Case Differences","text":""},{"location":"comparison/multilock-implementation/#redlock4j-multilock_1","title":"redlock4j MultiLock","text":"<p>Best For: - Locking multiple resources on the same Redis cluster - Scenarios requiring strict deadlock prevention - Atomic operations across multiple keys - Distributed systems with quorum requirements</p> <p>Example Scenarios: <pre><code>// Bank transfer between multiple accounts\nMultiLock lock = new MultiLock(\n    Arrays.asList(\"account:1\", \"account:2\", \"account:3\"),\n    redisDrivers, config\n);\n\n// Inventory management across warehouses\nMultiLock lock = new MultiLock(\n    Arrays.asList(\"warehouse:A:item:123\", \"warehouse:B:item:123\"),\n    redisDrivers, config\n);\n</code></pre></p>"},{"location":"comparison/multilock-implementation/#redisson-redissonmultilock_1","title":"Redisson RedissonMultiLock","text":"<p>Best For: - Grouping locks from different Redis instances - Coordinating across multiple independent systems - Flexible lock composition - When you already have RLock objects</p> <p>Example Scenarios: <pre><code>// Locks from different Redis clusters\nRLock lock1 = redisson1.getLock(\"resource1\"); // Cluster 1\nRLock lock2 = redisson2.getLock(\"resource2\"); // Cluster 2\nRLock lock3 = redisson3.getLock(\"resource3\"); // Cluster 3\nRedissonMultiLock multiLock = new RedissonMultiLock(lock1, lock2, lock3);\n\n// Mix different lock types\nRLock fairLock = redisson.getFairLock(\"fair\");\nRLock readLock = redisson.getReadWriteLock(\"rw\").readLock();\nRedissonMultiLock multiLock = new RedissonMultiLock(fairLock, readLock);\n</code></pre></p>"},{"location":"comparison/multilock-implementation/#safety-correctness","title":"Safety &amp; Correctness","text":""},{"location":"comparison/multilock-implementation/#redlock4j_7","title":"redlock4j","text":"<p>Safety Guarantees: - \u2705 Deadlock-free (automatic key sorting) - \u2705 Quorum-based consistency - \u2705 All-or-nothing atomicity - \u2705 Clock drift compensation - \u2705 Validity time enforcement</p> <p>Potential Issues: - \u26a0\ufe0f All resources must be on same Redis cluster - \u26a0\ufe0f Higher latency due to quorum requirement - \u26a0\ufe0f More network overhead (N\u00d7M operations)</p>"},{"location":"comparison/multilock-implementation/#redisson_7","title":"Redisson","text":"<p>Safety Guarantees: - \u2705 Flexible lock composition - \u2705 Works across different Redis instances - \u2705 Extensible failure tolerance - \u2705 Async/reactive support</p> <p>Potential Issues: - \u26a0\ufe0f No automatic deadlock prevention - \u26a0\ufe0f Developer must ensure lock ordering - \u26a0\ufe0f Sequential acquisition (slower for many locks) - \u26a0\ufe0f No quorum mechanism by default</p>"},{"location":"comparison/multilock-implementation/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"comparison/multilock-implementation/#redlock4j_8","title":"redlock4j","text":"<p>Code Complexity: ~370 lines</p> <p>Pros: - \u2705 Integrated Redlock implementation - \u2705 Automatic deadlock prevention - \u2705 Clear all-or-nothing semantics - \u2705 Single validity time - \u2705 Thread-local state (fast reentrancy)</p> <p>Cons: - \u274c Limited to single Redis cluster - \u274c More Redis operations - \u274c Higher network overhead - \u274c Less flexible composition</p>"},{"location":"comparison/multilock-implementation/#redisson_8","title":"Redisson","text":"<p>Code Complexity: ~450 lines (with async support)</p> <p>Pros: - \u2705 Works across multiple Redis instances - \u2705 Flexible lock composition - \u2705 Extensible (can override failedLocksLimit) - \u2705 Async/reactive support - \u2705 Can mix different lock types</p> <p>Cons: - \u274c No deadlock prevention - \u274c Sequential acquisition - \u274c More complex retry logic - \u274c Requires careful lock ordering</p>"},{"location":"comparison/multilock-implementation/#redissonredlock-vs-redlock4j-multilock","title":"RedissonRedLock vs redlock4j MultiLock","text":"<p>Redisson also has <code>RedissonRedLock</code> which extends <code>RedissonMultiLock</code>:</p>"},{"location":"comparison/multilock-implementation/#redissonredlock","title":"RedissonRedLock","text":"<pre><code>public class RedissonRedLock extends RedissonMultiLock {\n\n    @Override\n    protected int failedLocksLimit() {\n        return locks.size() - minLocksAmount(locks);\n    }\n\n    protected int minLocksAmount(List&lt;RLock&gt; locks) {\n        return locks.size() / 2 + 1; // Quorum\n    }\n}\n</code></pre> <p>Key Difference: Implements quorum-based failure tolerance</p> <p>Comparison with redlock4j MultiLock:</p> Feature redlock4j MultiLock RedissonRedLock Purpose Multiple resources on same cluster Multiple independent Redis instances Quorum Per-resource across nodes Across different locks Deadlock Prevention Automatic (sorted keys) Manual (developer responsibility) Acquisition Parallel per node Sequential across locks Use Case Multi-resource locking Multi-instance Redlock"},{"location":"comparison/multilock-implementation/#recommendations","title":"Recommendations","text":""},{"location":"comparison/multilock-implementation/#choose-redlock4j-multilock-when","title":"Choose redlock4j MultiLock when:","text":"<ul> <li>\u2705 Locking multiple resources on the same Redis cluster</li> <li>\u2705 Need automatic deadlock prevention</li> <li>\u2705 Require strict all-or-nothing semantics</li> <li>\u2705 Want quorum-based safety per resource</li> <li>\u2705 Prefer simpler, integrated solution</li> </ul>"},{"location":"comparison/multilock-implementation/#choose-redisson-redissonmultilock-when","title":"Choose Redisson RedissonMultiLock when:","text":"<ul> <li>\u2705 Need to coordinate locks across different Redis instances</li> <li>\u2705 Want to compose different lock types</li> <li>\u2705 Require async/reactive support</li> <li>\u2705 Can manage lock ordering manually</li> <li>\u2705 Need flexible failure tolerance</li> </ul>"},{"location":"comparison/multilock-implementation/#choose-redisson-redissonredlock-when","title":"Choose Redisson RedissonRedLock when:","text":"<ul> <li>\u2705 Implementing Redlock across multiple Redis instances</li> <li>\u2705 Each lock represents a different Redis master</li> <li>\u2705 Need quorum-based distributed locking</li> <li>\u2705 Can ensure proper lock ordering</li> </ul>"},{"location":"comparison/multilock-implementation/#migration-considerations","title":"Migration Considerations","text":""},{"location":"comparison/multilock-implementation/#from-redisson-to-redlock4j","title":"From Redisson to redlock4j","text":"<pre><code>// Before (Redisson)\nRLock lock1 = redisson.getLock(\"account:1\");\nRLock lock2 = redisson.getLock(\"account:2\");\nRLock lock3 = redisson.getLock(\"account:3\");\nRedissonMultiLock multiLock = new RedissonMultiLock(lock1, lock2, lock3);\nmultiLock.lock();\ntry {\n    // work\n} finally {\n    multiLock.unlock();\n}\n\n// After (redlock4j)\nMultiLock multiLock = new MultiLock(\n    Arrays.asList(\"account:1\", \"account:2\", \"account:3\"),\n    redisDrivers,\n    config\n);\nmultiLock.lock();\ntry {\n    // work\n} finally {\n    multiLock.unlock();\n}\n</code></pre> <p>Benefits: - Automatic deadlock prevention - Quorum-based safety - Simpler API</p> <p>Considerations: - All resources must be on same cluster - Different performance characteristics</p>"},{"location":"comparison/multilock-implementation/#from-redlock4j-to-redisson","title":"From redlock4j to Redisson","text":"<pre><code>// Before (redlock4j)\nMultiLock multiLock = new MultiLock(\n    Arrays.asList(\"resource1\", \"resource2\", \"resource3\"),\n    redisDrivers,\n    config\n);\n\n// After (Redisson) - if using multiple instances\nRLock lock1 = redisson1.getLock(\"resource1\");\nRLock lock2 = redisson2.getLock(\"resource2\");\nRLock lock3 = redisson3.getLock(\"resource3\");\nRedissonRedLock multiLock = new RedissonRedLock(lock1, lock2, lock3);\n</code></pre> <p>Benefits: - Can use different Redis instances - Async/reactive support - More flexible composition</p> <p>Considerations: - Must ensure consistent lock ordering - Different acquisition semantics</p>"},{"location":"comparison/multilock-implementation/#conclusion","title":"Conclusion","text":"<p>Both implementations serve different purposes:</p> <p>redlock4j MultiLock: - Designed for locking multiple resources on the same distributed Redis cluster - Automatic deadlock prevention through key sorting - Quorum-based safety per resource - All-or-nothing atomic acquisition - Simpler, more focused implementation</p> <p>Redisson RedissonMultiLock: - Designed for grouping independent locks (possibly from different instances) - Flexible composition of different lock types - Sequential acquisition with retry logic - Requires manual deadlock prevention - More flexible but more complex</p> <p>Redisson RedissonRedLock: - Implements Redlock algorithm across multiple Redis instances - Quorum-based failure tolerance - Similar goals to redlock4j but different scope (instances vs resources)</p> <p>Choose based on your specific requirements: - Same cluster, multiple resources \u2192 redlock4j MultiLock - Multiple instances, flexible composition \u2192 Redisson RedissonMultiLock - Multiple instances, Redlock algorithm \u2192 Redisson RedissonRedLock     boolean acquired = successfulNodes &gt;= config.getQuorum()                     &amp;&amp; validityTime &gt; 0;</p> <pre><code>// 4. Rollback if failed\nif (!acquired) {\n    releaseAllLocks(lockValues);\n}\n\nreturn new MultiLockResult(acquired, validityTime, lockValues, ...);\n</code></pre> <p>} <code>**Per-Node Acquisition**:</code>java private boolean acquireAllOnNode(RedisDriver driver, Map lockValues) {     List acquiredKeys = new ArrayList&lt;&gt;();      for (String key : lockKeys) {         if (driver.setIfNotExists(key, lockValue, timeout)) {             acquiredKeys.add(key);         } else {             // Failed - rollback this node             rollbackOnNode(driver, lockValues, acquiredKeys);             return false;         }     }     return true; } ``` <p>Flow: 1. Generate unique lock values for all keys 2. For each Redis node:    - Try to acquire ALL locks    - If any fails, rollback that node 3. Check if quorum achieved 4. If not, release all acquired locks</p>"},{"location":"comparison/readwritelock-implementation/","title":"ReadWriteLock Implementation Comparison: redlock4j vs Redisson","text":"<p>This document provides a detailed technical comparison of the ReadWriteLock implementations in redlock4j and Redisson.</p>"},{"location":"comparison/readwritelock-implementation/#overview","title":"Overview","text":"<p>Both libraries implement distributed read-write locks to allow multiple concurrent readers or a single exclusive writer, but they use different data structures and synchronization mechanisms.</p>"},{"location":"comparison/readwritelock-implementation/#purpose-use-case","title":"Purpose &amp; Use Case","text":""},{"location":"comparison/readwritelock-implementation/#redlock4j-redlockreadwritelock","title":"redlock4j RedlockReadWriteLock","text":"<p>Purpose: Distributed read-write lock with quorum-based safety guarantees</p> <p>Use Case: Scenarios requiring strong consistency for read-heavy workloads</p> <pre><code>RedlockReadWriteLock rwLock = new RedlockReadWriteLock(\n    \"resource\", redisDrivers, config\n);\n\n// Multiple readers can acquire simultaneously\nrwLock.readLock().lock();\ntry {\n    readData();\n} finally {\n    rwLock.readLock().unlock();\n}\n\n// Writer has exclusive access\nrwLock.writeLock().lock();\ntry {\n    writeData();\n} finally {\n    rwLock.writeLock().unlock();\n}\n</code></pre>"},{"location":"comparison/readwritelock-implementation/#redisson-redissonreadwritelock","title":"Redisson RedissonReadWriteLock","text":"<p>Purpose: Distributed read-write lock with pub/sub notifications</p> <p>Use Case: High-performance read-write scenarios with single Redis instance</p> <pre><code>RReadWriteLock rwLock = redisson.getReadWriteLock(\"resource\");\n\n// Read lock\nrwLock.readLock().lock();\ntry {\n    readData();\n} finally {\n    rwLock.readLock().unlock();\n}\n\n// Write lock\nrwLock.writeLock().lock();\ntry {\n    writeData();\n} finally {\n    rwLock.writeLock().unlock();\n}\n</code></pre>"},{"location":"comparison/readwritelock-implementation/#architecture-data-model","title":"Architecture &amp; Data Model","text":""},{"location":"comparison/readwritelock-implementation/#redlock4j","title":"redlock4j","text":"<p>Design: Counter-based with separate write lock</p> <p>Data Structure: <pre><code>{resourceKey}:readers = {count}                    (reader counter)\n{resourceKey}:readers:{lockValue1} = \"1\"           (individual reader tracking)\n{resourceKey}:readers:{lockValue2} = \"1\"           (individual reader tracking)\n{resourceKey}:write = {lockValue}                  (exclusive write lock)\n</code></pre></p> <p>Key Characteristics: - Reader count tracked via <code>INCR</code>/<code>DECR</code> - Individual reader keys for tracking - Write lock uses standard Redlock - Quorum-based for both read and write - Thread-local state for reentrancy</p> <p>Architecture: <pre><code>RedlockReadWriteLock\n  \u251c\u2500 ReadLock\n  \u2502   \u251c\u2500 readCountKey ({key}:readers)\n  \u2502   \u251c\u2500 writeLockKey ({key}:write)\n  \u2502   \u251c\u2500 ThreadLocal&lt;LockState&gt;\n  \u2502   \u2514\u2500 Quorum-based INCR/DECR\n  \u2514\u2500 WriteLock\n      \u251c\u2500 Redlock (for write lock)\n      \u251c\u2500 readCountKey ({key}:readers)\n      \u2514\u2500 Polling for reader count\n</code></pre></p>"},{"location":"comparison/readwritelock-implementation/#redisson","title":"Redisson","text":"<p>Design: Hash-based with mode tracking</p> <p>Data Structure: <pre><code>{resourceKey} = {\n  \"mode\": \"read\" or \"write\",\n  \"{threadId1}\": {holdCount},\n  \"{threadId2}\": {holdCount},\n  ...\n}\nredisson_rwlock:{resourceKey} = (pub/sub channel)\n</code></pre></p> <p>Key Characteristics: - Single hash stores all lock state - Mode field tracks read/write state - Thread IDs as hash fields - Lua scripts for atomicity - Pub/sub for notifications</p> <p>Architecture: <pre><code>RedissonReadWriteLock\n  \u251c\u2500 RedissonReadLock\n  \u2502   \u251c\u2500 Lua scripts for acquisition\n  \u2502   \u251c\u2500 Hash-based state\n  \u2502   \u2514\u2500 Pub/sub notifications\n  \u2514\u2500 RedissonWriteLock\n      \u251c\u2500 Lua scripts for acquisition\n      \u251c\u2500 Hash-based state\n      \u2514\u2500 Pub/sub notifications\n</code></pre></p>"},{"location":"comparison/readwritelock-implementation/#read-lock-acquisition","title":"Read Lock Acquisition","text":""},{"location":"comparison/readwritelock-implementation/#redlock4j_1","title":"redlock4j","text":"<p>Algorithm: Check write lock, then increment reader count</p> <pre><code>public boolean tryLock(long time, TimeUnit unit) {\n    // 1. Check reentrancy\n    LockState currentState = lockState.get();\n    if (currentState != null &amp;&amp; currentState.isValid()) {\n        currentState.incrementHoldCount();\n        return true;\n    }\n\n    // 2. Retry loop\n\n\n### Redisson\n\n**Algorithm**: Lua script with hash-based state management\n\n```lua\n-- tryLockInnerAsync (simplified)\nlocal mode = redis.call('hget', KEYS[1], 'mode');\n\n-- If no lock or already in read mode\nif (mode == false) then\n    redis.call('hset', KEYS[1], 'mode', 'read');\n    redis.call('hset', KEYS[1], ARGV[2], 1);\n    redis.call('pexpire', KEYS[1], ARGV[1]);\n    return nil;\nend;\n\nif (mode == 'read') or (mode == 'write' and redis.call('hexists', KEYS[1], ARGV[2]) == 1) then\n    local ind = redis.call('hincrby', KEYS[1], ARGV[2], 1);\n    local remainTime = redis.call('pttl', KEYS[1]);\n    redis.call('pexpire', KEYS[1], math.max(remainTime, ARGV[1]));\n    return nil;\nend;\n\n-- Write lock held by another thread\nreturn redis.call('pttl', KEYS[1]);\n</code></pre> <p>Flow: 1. Get current mode from hash 2. If no lock: set mode='read', add thread, set TTL 3. If read mode: increment thread's hold count 4. If write mode by same thread: allow (lock downgrade) 5. If write mode by other thread: return TTL</p> <p>Redis Operations: - 1 Lua script execution (atomic)</p>"},{"location":"comparison/readwritelock-implementation/#write-lock-acquisition","title":"Write Lock Acquisition","text":""},{"location":"comparison/readwritelock-implementation/#redlock4j_2","title":"redlock4j","text":"<p>Algorithm: Wait for readers, then acquire exclusive lock</p> <pre><code>public boolean tryLock(long time, TimeUnit unit) {\n    long timeoutMs = unit.toMillis(time);\n    long startTime = System.currentTimeMillis();\n\n    // 1. Wait for readers to finish\n    while (hasActiveReaders()) {\n        if (timeoutExceeded(startTime, timeoutMs)) {\n            return false;\n        }\n        Thread.sleep(retryDelayMs);\n    }\n\n    // 2. Acquire write lock using standard Redlock\n    long remainingTime = timeoutMs - elapsed;\n    return underlyingLock.tryLock(remainingTime, TimeUnit.MILLISECONDS);\n}\n\nprivate boolean hasActiveReaders() {\n    int nodesWithoutReaders = 0;\n\n    for (RedisDriver driver : redisDrivers) {\n        String countStr = driver.get(readCountKey);\n        if (countStr == null || Long.parseLong(countStr) &lt;= 0) {\n            nodesWithoutReaders++;\n        }\n    }\n\n    // Quorum of nodes must have no readers\n    return nodesWithoutReaders &lt; quorum;\n}\n</code></pre> <p>Flow: 1. Poll reader count on all nodes 2. Wait until quorum shows no readers 3. Acquire exclusive lock via Redlock 4. Check timeout throughout</p> <p>Redis Operations (M nodes): - N \u00d7 M <code>GET</code> (polling reader count) - M \u00d7 <code>SET NX</code> (Redlock acquisition)</p>"},{"location":"comparison/readwritelock-implementation/#redisson_1","title":"Redisson","text":"<p>Algorithm: Lua script with mode transition</p> <pre><code>-- tryLockInnerAsync (simplified)\nlocal mode = redis.call('hget', KEYS[1], 'mode');\n\n-- No lock exists\nif (mode == false) then\n    redis.call('hset', KEYS[1], 'mode', 'write');\n    redis.call('hset', KEYS[1], ARGV[2], 1);\n    redis.call('pexpire', KEYS[1], ARGV[1]);\n    return nil;\nend;\n\n-- Same thread already holds write lock (reentrant)\nif (mode == 'write') then\n    if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then\n        redis.call('hincrby', KEYS[1], ARGV[2], 1);\n        redis.call('pexpire', KEYS[1], ARGV[1]);\n        return nil;\n    end;\nend;\n\n-- Same thread holds read lock (lock upgrade)\nif (mode == 'read') then\n    local ind = redis.call('hget', KEYS[1], ARGV[2]);\n    if (ind ~= false) then\n        -- Check if this is the only reader\n        if (redis.call('hlen', KEYS[1]) == 2) then -- mode + this thread\n            redis.call('hset', KEYS[1], 'mode', 'write');\n            return nil;\n        end;\n    end;\nend;\n\n-- Lock held by others\nreturn redis.call('pttl', KEYS[1]);\n</code></pre> <p>Flow: 1. Get current mode 2. If no lock: set mode='write', add thread 3. If write mode by same thread: increment (reentrant) 4. If read mode by same thread only: upgrade to write 5. If held by others: return TTL</p> <p>Redis Operations: - 1 Lua script execution (atomic)</p>"},{"location":"comparison/readwritelock-implementation/#read-lock-release","title":"Read Lock Release","text":""},{"location":"comparison/readwritelock-implementation/#redlock4j_3","title":"redlock4j","text":"<p>Algorithm: Decrement reader count</p> <pre><code>public void unlock() {\n    LockState state = lockState.get();\n\n    // Handle reentrancy\n    int remainingHolds = state.decrementHoldCount();\n    if (remainingHolds &gt; 0) {\n        return;\n    }\n\n    // Decrement reader count on all nodes\n    decrementReaderCount(state.lockValue);\n    lockState.remove();\n}\n\nprivate void decrementReaderCount(String lockValue) {\n    for (RedisDriver driver : redisDrivers) {\n        // Decrement counter\n        long count = driver.decr(readCountKey);\n\n        // Delete individual reader key\n        driver.del(readCountKey + \":\" + lockValue);\n\n        // Clean up counter if zero\n        if (count &lt;= 0) {\n            driver.del(readCountKey);\n        }\n    }\n}\n</code></pre> <p>Characteristics: - DECR on all nodes - Delete individual reader key - Clean up counter when zero - No notification to waiting writers</p> <p>Redis Operations (M nodes): - M \u00d7 <code>DECR</code> - M \u00d7 <code>DEL</code> (individual key) - M \u00d7 <code>DEL</code> (counter, if zero)</p>"},{"location":"comparison/readwritelock-implementation/#redisson_2","title":"Redisson","text":"<p>Algorithm: Lua script with notification</p> <pre><code>-- unlockInnerAsync (simplified)\nlocal mode = redis.call('hget', KEYS[1], 'mode');\nif (mode == false) then\n    return 1; -- Already unlocked\nend;\n\nlocal lockExists = redis.call('hexists', KEYS[1], ARGV[2]);\nif (lockExists == 0) then\n    return nil; -- Not held by this thread\nend;\n\nlocal counter = redis.call('hincrby', KEYS[1], ARGV[2], -1);\nif (counter &gt; 0) then\n    redis.call('pexpire', KEYS[1], ARGV[1]);\n    return 0; -- Still held (reentrant)\nend;\n\nredis.call('hdel', KEYS[1], ARGV[2]);\nif (redis.call('hlen', KEYS[1]) &gt; 1) then\n    -- Other readers still exist\n    redis.call('pexpire', KEYS[1], ARGV[1]);\n    return 0;\nend;\n\n-- Last reader, delete lock and notify\nredis.call('del', KEYS[1]);\nredis.call('publish', KEYS[2], ARGV[1]);\nreturn 1;\n</code></pre> <p>Characteristics: - Atomic decrement in hash - Delete thread field when zero - Publish notification when last reader - Waiting writers wake up immediately</p> <p>Redis Operations: - 1 Lua script execution - 1 <code>PUBLISH</code> (if last reader)</p>"},{"location":"comparison/readwritelock-implementation/#write-lock-release","title":"Write Lock Release","text":""},{"location":"comparison/readwritelock-implementation/#redlock4j_4","title":"redlock4j","text":"<p>Algorithm: Standard Redlock unlock</p> <pre><code>public void unlock() {\n    underlyingLock.unlock(); // Delegates to Redlock\n}\n</code></pre> <p>Characteristics: - Uses Redlock unlock mechanism - Delete if value matches - No notification to waiting readers/writers</p> <p>Redis Operations (M nodes): - M \u00d7 Lua script (delete if matches)</p>"},{"location":"comparison/readwritelock-implementation/#redisson_3","title":"Redisson","text":"<p>Algorithm: Lua script with notification</p> <pre><code>-- Similar to read unlock but for write mode\n-- Decrements hold count, deletes when zero, publishes notification\n</code></pre> <p>Characteristics: - Atomic decrement in hash - Delete lock when zero - Publish notification to all waiters - Immediate wake-up</p> <p>Redis Operations: - 1 Lua script execution - 1 <code>PUBLISH</code></p>"},{"location":"comparison/readwritelock-implementation/#lock-upgradedowngrade","title":"Lock Upgrade/Downgrade","text":""},{"location":"comparison/readwritelock-implementation/#redlock4j_5","title":"redlock4j","text":"<p>Lock Upgrade (Read \u2192 Write): Not supported</p> <p>Lock Downgrade (Write \u2192 Read): Not supported</p> <p>Characteristics: - Must release read lock before acquiring write lock - Must release write lock before acquiring read lock - No automatic conversion - Prevents potential deadlocks</p>"},{"location":"comparison/readwritelock-implementation/#redisson_4","title":"Redisson","text":"<p>Lock Upgrade (Read \u2192 Write): Supported (single reader only)</p> <pre><code>-- If this thread is the only reader, can upgrade to write\nif (mode == 'read') then\n    if (redis.call('hlen', KEYS[1]) == 2) then -- mode + this thread\n        redis.call('hset', KEYS[1], 'mode', 'write');\n        return nil;\n    end;\nend;\n</code></pre> <p>Lock Downgrade (Write \u2192 Read): Supported</p> <pre><code>-- If thread holds write lock, can acquire read lock (downgrade)\nif (mode == 'write' and redis.call('hexists', KEYS[1], ARGV[2]) == 1) then\n    local ind = redis.call('hincrby', KEYS[1], ARGV[2], 1);\n    return nil;\nend;\n</code></pre> <p>Characteristics: - Automatic lock downgrade (write \u2192 read) - Lock upgrade only if sole reader - Prevents deadlock from multiple readers upgrading - More flexible but more complex</p>"},{"location":"comparison/readwritelock-implementation/#fairness-ordering","title":"Fairness &amp; Ordering","text":""},{"location":"comparison/readwritelock-implementation/#redlock4j_6","title":"redlock4j","text":"<p>Fairness: Non-fair (no ordering guarantees)</p> <p>Characteristics: - Readers and writers compete equally - No FIFO queue - Retry-based acquisition - Potential writer starvation if many readers</p> <p>Example: <pre><code>Reader 1: acquire \u2192 success\nReader 2: acquire \u2192 success\nWriter 1: tryLock \u2192 blocks (waiting for readers)\nReader 3: acquire \u2192 success (can acquire while writer waits)\nWriter 1: still waiting...\n</code></pre></p>"},{"location":"comparison/readwritelock-implementation/#redisson_5","title":"Redisson","text":"<p>Fairness: Non-fair by default</p> <p>Characteristics: - No ordering between readers and writers - Pub/sub wakes all waiters - Race to acquire after notification - Also has <code>RedissonFairReadWriteLock</code> for FIFO ordering</p> <p>Note: Redisson provides <code>RedissonFairReadWriteLock</code> for fair ordering with FIFO guarantees.</p>"},{"location":"comparison/readwritelock-implementation/#performance-comparison","title":"Performance Comparison","text":""},{"location":"comparison/readwritelock-implementation/#redlock4j_7","title":"redlock4j","text":"<p>Read Lock Acquisition (M nodes): - M \u00d7 <code>GET</code> (check write lock) - M \u00d7 <code>INCR</code> (increment counter) - M \u00d7 <code>SETEX</code> (individual reader key) - Total: 3M operations</p> <p>Write Lock Acquisition (M nodes): - N \u00d7 M <code>GET</code> (poll reader count) - M \u00d7 <code>SET NX</code> (Redlock) - Total: (N+1)M operations</p> <p>Complexity: O(M) for reads, O(N\u00d7M) for writes</p> <p>Latency: - Higher due to quorum requirement - Polling overhead for writers - No pub/sub overhead</p>"},{"location":"comparison/readwritelock-implementation/#redisson_6","title":"Redisson","text":"<p>Read Lock Acquisition: - 1 Lua script execution - If blocked: 1 pub/sub subscription - Total: 1-2 operations</p> <p>Write Lock Acquisition: - 1 Lua script execution - If blocked: 1 pub/sub subscription - Total: 1-2 operations</p> <p>Complexity: O(1) per operation</p> <p>Latency: - Lower for single instance - Single round trip - Pub/sub notification overhead</p>"},{"location":"comparison/readwritelock-implementation/#safety-correctness","title":"Safety &amp; Correctness","text":""},{"location":"comparison/readwritelock-implementation/#redlock4j_8","title":"redlock4j","text":"<p>Safety Guarantees: - \u2705 Quorum-based consistency - \u2705 Survives minority node failures - \u2705 Multiple readers guaranteed - \u2705 Exclusive writer guaranteed - \u2705 No single point of failure</p> <p>Potential Issues: - \u26a0\ufe0f Higher latency - \u26a0\ufe0f More network overhead - \u26a0\ufe0f Polling-based (no notifications) - \u26a0\ufe0f Potential writer starvation - \u26a0\ufe0f No lock upgrade/downgrade</p> <p>Consistency Model: <pre><code>Read lock acquired if:\n  - Quorum shows no write lock\n  - Reader count incremented on quorum\n\nWrite lock acquired if:\n  - Quorum shows no readers\n  - Exclusive lock acquired on quorum\n</code></pre></p>"},{"location":"comparison/readwritelock-implementation/#redisson_7","title":"Redisson","text":"<p>Safety Guarantees: - \u2705 Atomic operations (Lua scripts) - \u2705 Multiple readers guaranteed - \u2705 Exclusive writer guaranteed - \u2705 Lock upgrade/downgrade support - \u2705 Pub/sub notifications - \u2705 Async/reactive support</p> <p>Potential Issues: - \u26a0\ufe0f Single point of failure - \u26a0\ufe0f No quorum mechanism - \u26a0\ufe0f Potential writer starvation (non-fair) - \u26a0\ufe0f More complex Lua scripts</p> <p>Consistency Model: <pre><code>Lock acquired if:\n  - Mode allows acquisition\n  - Atomic state transition succeeds\n  - No distributed consistency\n</code></pre></p>"},{"location":"comparison/readwritelock-implementation/#use-case-comparison","title":"Use Case Comparison","text":""},{"location":"comparison/readwritelock-implementation/#redlock4j-redlockreadwritelock_1","title":"redlock4j RedlockReadWriteLock","text":"<p>Best For: - Distributed systems requiring quorum-based safety - Read-heavy workloads with strong consistency - Multi-master Redis setups - Fault-tolerant read-write scenarios - Can tolerate higher latency</p> <p>Example Scenarios: <pre><code>// Distributed cache with strong consistency\nRedlockReadWriteLock cacheLock = new RedlockReadWriteLock(\n    \"cache:users\", redisDrivers, config\n);\n\n// Configuration management\nRedlockReadWriteLock configLock = new RedlockReadWriteLock(\n    \"config:app\", redisDrivers, config\n);\n</code></pre></p>"},{"location":"comparison/readwritelock-implementation/#redisson-redissonreadwritelock_1","title":"Redisson RedissonReadWriteLock","text":"<p>Best For: - Single Redis instance deployments - High-throughput read-write scenarios - Applications needing async/reactive APIs - Lock upgrade/downgrade requirements - Low-latency requirements</p> <p>Example Scenarios: <pre><code>// High-performance cache\nRReadWriteLock cacheLock = redisson.getReadWriteLock(\"cache:users\");\n\n// Document editing with lock downgrade\nRReadWriteLock docLock = redisson.getReadWriteLock(\"doc:123\");\ndocLock.writeLock().lock();\ntry {\n    editDocument();\n    docLock.readLock().lock(); // Downgrade\n    docLock.writeLock().unlock();\n    try {\n        readDocument();\n    } finally {\n        docLock.readLock().unlock();\n    }\n} finally {\n    if (docLock.writeLock().isHeldByCurrentThread()) {\n        docLock.writeLock().unlock();\n    }\n}\n</code></pre></p>"},{"location":"comparison/readwritelock-implementation/#feature-comparison-table","title":"Feature Comparison Table","text":"Feature redlock4j Redisson Data Model Counter + individual keys Hash with mode field Quorum Yes No Fault Tolerance Survives minority failures Single point of failure Lock Upgrade No Yes (single reader only) Lock Downgrade No Yes Waiting Mechanism Polling Pub/sub Fairness Non-fair Non-fair (fair variant available) Async Support No Yes Reactive Support No Yes Performance O(M) reads, O(N\u00d7M) writes O(1) Latency Higher Lower Network Overhead High Low Atomicity Quorum-based Lua scripts"},{"location":"comparison/readwritelock-implementation/#recommendations","title":"Recommendations","text":""},{"location":"comparison/readwritelock-implementation/#choose-redlock4j-redlockreadwritelock-when","title":"Choose redlock4j RedlockReadWriteLock when:","text":"<ul> <li>\u2705 Need quorum-based distributed consistency</li> <li>\u2705 Require fault tolerance (multi-master)</li> <li>\u2705 Read-heavy workloads with strong consistency</li> <li>\u2705 Can tolerate higher latency</li> <li>\u2705 Don't need lock upgrade/downgrade</li> </ul>"},{"location":"comparison/readwritelock-implementation/#choose-redisson-redissonreadwritelock-when","title":"Choose Redisson RedissonReadWriteLock when:","text":"<ul> <li>\u2705 Single Redis instance is acceptable</li> <li>\u2705 Need high throughput / low latency</li> <li>\u2705 Require lock upgrade/downgrade</li> <li>\u2705 Need async/reactive APIs</li> <li>\u2705 Want pub/sub notifications</li> <li>\u2705 Need fair ordering (use RedissonFairReadWriteLock)</li> </ul>"},{"location":"comparison/readwritelock-implementation/#conclusion","title":"Conclusion","text":"<p>Both implementations provide distributed read-write locks with different trade-offs:</p> <p>redlock4j RedlockReadWriteLock: - Counter-based with quorum safety - Higher latency but fault-tolerant - Polling-based waiting - No lock conversion support - Best for multi-master setups requiring strong consistency</p> <p>Redisson RedissonReadWriteLock: - Hash-based with atomic Lua scripts - Lower latency but single point of failure - Pub/sub notifications - Lock upgrade/downgrade support - Best for high-throughput single-instance deployments</p> <p>Choose based on your specific requirements: - Distributed consistency &amp; fault tolerance \u2192 redlock4j - High throughput &amp; low latency \u2192 Redisson - Fair ordering \u2192 Redisson RedissonFairReadWriteLock</p>"},{"location":"comparison/semaphore-implementation/","title":"Semaphore Implementation Comparison: redlock4j vs Redisson","text":"<p>This document provides a detailed technical comparison of the Semaphore implementations in redlock4j and Redisson.</p>"},{"location":"comparison/semaphore-implementation/#overview","title":"Overview","text":"<p>Both libraries implement distributed semaphores to limit concurrent access to resources, but they use fundamentally different approaches and data structures.</p>"},{"location":"comparison/semaphore-implementation/#purpose-use-case","title":"Purpose &amp; Use Case","text":""},{"location":"comparison/semaphore-implementation/#redlock4j-redlocksemaphore","title":"redlock4j RedlockSemaphore","text":"<p>Purpose: Distributed semaphore with quorum-based safety guarantees</p> <p>Use Case: Rate limiting and resource pooling with strong consistency requirements</p> <pre><code>// Create a semaphore with 5 permits\nRedlockSemaphore semaphore = new RedlockSemaphore(\n    \"api-limiter\", 5, redisDrivers, config\n);\n\n// Acquire a permit\nif (semaphore.tryAcquire(5, TimeUnit.SECONDS)) {\n    try {\n        // Perform rate-limited operation\n        callExternalAPI();\n    } finally {\n        semaphore.release();\n    }\n}\n</code></pre>"},{"location":"comparison/semaphore-implementation/#redisson-redissonsemaphore","title":"Redisson RedissonSemaphore","text":"<p>Purpose: Distributed semaphore with pub/sub notification</p> <p>Use Case: General-purpose semaphore with async support and efficient waiting</p> <pre><code>RSemaphore semaphore = redisson.getSemaphore(\"api-limiter\");\nsemaphore.trySetPermits(5);\n\n// Acquire a permit\nif (semaphore.tryAcquire(5, TimeUnit.SECONDS)) {\n    try {\n        // Perform rate-limited operation\n        callExternalAPI();\n    } finally {\n        semaphore.release();\n    }\n}\n</code></pre>"},{"location":"comparison/semaphore-implementation/#architecture-data-model","title":"Architecture &amp; Data Model","text":""},{"location":"comparison/semaphore-implementation/#redlock4j","title":"redlock4j","text":"<p>Design: Individual permit keys with quorum-based acquisition</p> <p>Data Structure: <pre><code>{semaphoreKey}:permit:{permitId1} = {permitId1}  (TTL: lockTimeout)\n{semaphoreKey}:permit:{permitId2} = {permitId2}  (TTL: lockTimeout)\n{semaphoreKey}:permit:{permitId3} = {permitId3}  (TTL: lockTimeout)\n...\n</code></pre></p> <p>Key Characteristics: - Each permit is a separate Redis key - Permit acquisition uses <code>SET NX</code> (same as lock) - Quorum required for each permit - No central counter - Thread-local state tracking</p> <p>Architecture: <pre><code>RedlockSemaphore\n  \u251c\u2500 semaphoreKey (base key)\n  \u251c\u2500 maxPermits (configured limit)\n  \u251c\u2500 List&lt;RedisDriver&gt; (quorum-based)\n  \u2514\u2500 ThreadLocal&lt;PermitState&gt;\n       \u251c\u2500 List&lt;String&gt; permitIds\n       \u251c\u2500 acquisitionTime\n       \u2514\u2500 validityTime\n</code></pre></p>"},{"location":"comparison/semaphore-implementation/#redisson","title":"Redisson","text":"<p>Design: Single counter with pub/sub notification</p> <p>Data Structure: <pre><code>{semaphoreKey} = {availablePermits}  (integer counter)\nredisson_sc:{semaphoreKey} = (pub/sub channel)\n</code></pre></p> <p>Key Characteristics: - Single Redis key stores available permit count - Uses <code>DECRBY</code> for acquisition, <code>INCRBY</code> for release - Pub/sub for efficient waiting - No quorum mechanism - Async/reactive support</p> <p>Architecture: <pre><code>RedissonSemaphore\n  \u251c\u2500 semaphoreKey (counter key)\n  \u251c\u2500 channelName (pub/sub)\n  \u251c\u2500 SemaphorePubSub (notification)\n  \u2514\u2500 No thread-local state\n</code></pre></p>"},{"location":"comparison/semaphore-implementation/#permit-acquisition-algorithm","title":"Permit Acquisition Algorithm","text":""},{"location":"comparison/semaphore-implementation/#redlock4j_1","title":"redlock4j","text":"<p>Algorithm: Create individual permit keys with quorum</p> <pre><code>private SemaphoreResult attemptAcquire(int permits) {\n    List&lt;String&gt; permitIds = new ArrayList&lt;&gt;();\n\n    // 1. For each permit needed\n    for (int i = 0; i &lt; permits; i++) {\n        String permitId = generatePermitId();\n        String permitKey = semaphoreKey + \":permit:\" + permitId;\n\n        // 2. Try to acquire on each Redis node\n        int successfulNodes = 0;\n        for (RedisDriver driver : redisDrivers) {\n            if (driver.setIfNotExists(permitKey, permitId, timeout)) {\n                successfulNodes++;\n            }\n        }\n\n        // 3. Check quorum for this permit\n        if (successfulNodes &gt;= config.getQuorum()) {\n            permitIds.add(permitId);\n        } else {\n            // Failed - rollback all permits\n            releasePermits(permitIds);\n            return new SemaphoreResult(false, 0, new ArrayList&lt;&gt;());\n        }\n    }\n\n    // 4. Check validity time\n    long validityTime = timeout - elapsedTime - driftTime;\n    boolean acquired = permitIds.size() == permits &amp;&amp; validityTime &gt; 0;\n\n\n\n### Redisson\n\n**Algorithm**: Atomic counter decrement with Lua script\n\n```lua\n-- tryAcquireAsync0\nlocal value = redis.call('get', KEYS[1]);\nif (value ~= false and tonumber(value) &gt;= tonumber(ARGV[1])) then\n    local val = redis.call('decrby', KEYS[1], ARGV[1]);\n    return 1;\nend;\nreturn 0;\n</code></pre> <p>Flow: 1. Get current permit count 2. Check if enough permits available 3. Atomically decrement counter 4. Return success/failure</p> <p>Redis Operations (for N permits): - 1 Lua script execution (atomic) - If waiting: pub/sub subscription + notifications</p> <p>Waiting Mechanism: <pre><code>public void acquire(int permits) throws InterruptedException {\n    if (tryAcquire(permits)) {\n        return; // Got it immediately\n    }\n\n    // Subscribe to notifications\n    CompletableFuture&lt;RedissonLockEntry&gt; future = subscribe();\n    RedissonLockEntry entry = future.get();\n\n    try {\n        while (true) {\n            if (tryAcquire(permits)) {\n                return; // Got it\n            }\n\n            // Wait for notification\n            entry.getLatch().acquire();\n        }\n    } finally {\n        unsubscribe(entry);\n    }\n}\n</code></pre></p>"},{"location":"comparison/semaphore-implementation/#permit-release-algorithm","title":"Permit Release Algorithm","text":""},{"location":"comparison/semaphore-implementation/#redlock4j_2","title":"redlock4j","text":"<p>Algorithm: Delete individual permit keys</p> <pre><code>private void releasePermits(List&lt;String&gt; permitIds) {\n    for (String permitId : permitIds) {\n        String permitKey = semaphoreKey + \":permit:\" + permitId;\n\n        // Delete on all nodes\n        for (RedisDriver driver : redisDrivers) {\n            driver.deleteIfValueMatches(permitKey, permitId);\n        }\n    }\n}\n</code></pre> <p>Characteristics: - Delete each permit key individually - No notification to waiting threads - Waiting threads discover via polling - Quorum-based deletion</p> <p>Redis Operations (for N permits on M nodes): - N \u00d7 M <code>DELETE</code> operations</p>"},{"location":"comparison/semaphore-implementation/#redisson_1","title":"Redisson","text":"<p>Algorithm: Atomic counter increment with pub/sub notification</p> <pre><code>-- releaseAsync\nlocal value = redis.call('incrby', KEYS[1], ARGV[1]);\nredis.call(ARGV[2], KEYS[2], value);\n</code></pre> <p>Characteristics: - Increment counter atomically - Publish notification to channel - Waiting threads wake up immediately - Single Redis operation</p> <p>Redis Operations (for N permits): - 1 Lua script execution - 1 <code>PUBLISH</code> to channel</p> <p>Notification Flow: <pre><code>Thread 1: acquire() \u2192 blocks \u2192 subscribes to channel\nThread 2: release() \u2192 INCRBY + PUBLISH\nThread 1: receives notification \u2192 wakes up \u2192 tryAcquire() \u2192 success\n</code></pre></p>"},{"location":"comparison/semaphore-implementation/#fairness-ordering","title":"Fairness &amp; Ordering","text":""},{"location":"comparison/semaphore-implementation/#redlock4j_3","title":"redlock4j","text":"<p>Fairness: Non-fair (no ordering guarantees)</p> <p>Characteristics: - Permits acquired in arbitrary order - No queue for waiting threads - Retry-based acquisition - First to successfully acquire wins</p> <p>Example: <pre><code>Thread 1: tryAcquire() \u2192 retry \u2192 retry \u2192 success\nThread 2: tryAcquire() \u2192 success (may acquire before Thread 1)\nThread 3: tryAcquire() \u2192 retry \u2192 timeout\n</code></pre></p>"},{"location":"comparison/semaphore-implementation/#redisson_2","title":"Redisson","text":"<p>Fairness: Non-fair (explicitly documented)</p> <p>Characteristics: - No FIFO ordering - Pub/sub wakes all waiters - Race to acquire after notification - First to execute Lua script wins</p> <p>Example: <pre><code>Thread 1: acquire() \u2192 blocks \u2192 subscribes\nThread 2: acquire() \u2192 blocks \u2192 subscribes\nThread 3: release() \u2192 PUBLISH\nThread 1 &amp; 2: wake up \u2192 race to tryAcquire()\nWinner: unpredictable\n</code></pre></p> <p>Note: Redisson also provides <code>RedissonPermitExpirableSemaphore</code> for fair semaphores with FIFO ordering.</p>"},{"location":"comparison/semaphore-implementation/#permit-counting-availability","title":"Permit Counting &amp; Availability","text":""},{"location":"comparison/semaphore-implementation/#redlock4j_4","title":"redlock4j","text":"<p>Counting: Implicit (count active permit keys)</p> <pre><code>public int availablePermits() {\n    // Note: This would require counting active permits across all nodes\n    // Current implementation returns maxPermits (placeholder)\n    return maxPermits;\n}\n</code></pre> <p>Challenges: - No central counter - Would need to count keys matching pattern - Expensive operation (SCAN on all nodes) - Not implemented accurately</p> <p>Actual Available Permits: <pre><code>Available = maxPermits - (number of active permit keys with quorum)\n</code></pre></p>"},{"location":"comparison/semaphore-implementation/#redisson_3","title":"Redisson","text":"<p>Counting: Explicit counter</p> <pre><code>public int availablePermits() {\n    return get(availablePermitsAsync());\n}\n\n// Implementation\npublic RFuture&lt;Integer&gt; availablePermitsAsync() {\n    return commandExecutor.writeAsync(\n        getRawName(), LongCodec.INSTANCE,\n        RedisCommands.GET_INTEGER, getRawName()\n    );\n}\n</code></pre> <p>Characteristics: - Single <code>GET</code> operation - Accurate and fast - O(1) complexity - Real-time availability</p>"},{"location":"comparison/semaphore-implementation/#initialization-configuration","title":"Initialization &amp; Configuration","text":""},{"location":"comparison/semaphore-implementation/#redlock4j_5","title":"redlock4j","text":"<p>Initialization: Implicit (no setup required)</p> <pre><code>// Create and use immediately\nRedlockSemaphore semaphore = new RedlockSemaphore(\n    \"api-limiter\", 5, redisDrivers, config\n);\n\n// No need to set permits - maxPermits is just a limit\nsemaphore.tryAcquire();\n</code></pre> <p>Characteristics: - <code>maxPermits</code> is a configuration parameter - No Redis initialization needed - Permits created on-demand - No way to \"drain\" or \"reset\" permits</p>"},{"location":"comparison/semaphore-implementation/#redisson_4","title":"Redisson","text":"<p>Initialization: Explicit (must set permits)</p> <pre><code>RSemaphore semaphore = redisson.getSemaphore(\"api-limiter\");\n\n// Must initialize before use\nsemaphore.trySetPermits(5);\n\n// Or add permits\nsemaphore.addPermits(5);\n\n// Now can use\nsemaphore.tryAcquire();\n</code></pre> <p>Characteristics: - Must explicitly set initial permits - <code>trySetPermits()</code> - sets only if not exists - <code>addPermits()</code> - adds to existing count - <code>drainPermits()</code> - removes all permits - Can reset/reconfigure at runtime</p> <p>Additional Operations: <pre><code>// Set permits with TTL\nsemaphore.trySetPermits(5, Duration.ofMinutes(10));\n\n// Drain all permits\nint drained = semaphore.drainPermits();\n\n// Release even if not held (add permits)\nsemaphore.addPermits(3);\n</code></pre></p>"},{"location":"comparison/semaphore-implementation/#timeout-validity","title":"Timeout &amp; Validity","text":""},{"location":"comparison/semaphore-implementation/#redlock4j_6","title":"redlock4j","text":"<p>Validity: Per-acquisition validity time</p> <pre><code>private static class PermitState {\n    final List&lt;String&gt; permitIds;\n    final long acquisitionTime;\n    final long validityTime; // Calculated validity\n\n    boolean isValid() {\n        return System.currentTimeMillis() &lt; acquisitionTime + validityTime;\n    }\n}\n</code></pre> <p>Characteristics: - Validity time calculated per acquisition - Clock drift compensation - Permits auto-expire via Redis TTL - Thread-local validity tracking</p> <p>Validity Calculation: <pre><code>long elapsedTime = System.currentTimeMillis() - startTime;\nlong driftTime = (long) (timeout * clockDriftFactor) + 2;\nlong validityTime = timeout - elapsedTime - driftTime;\n</code></pre></p>"},{"location":"comparison/semaphore-implementation/#redisson_5","title":"Redisson","text":"<p>Validity: No automatic expiration</p> <p>Characteristics: - Permits don't expire automatically - Counter persists indefinitely - Can set TTL on semaphore key explicitly - No validity tracking per acquisition</p> <p>Optional TTL: <pre><code>// Set permits with expiration\nsemaphore.trySetPermits(5, Duration.ofMinutes(10));\n\n// After 10 minutes, the entire semaphore key expires\n// All permits lost\n</code></pre></p>"},{"location":"comparison/semaphore-implementation/#performance-comparison","title":"Performance Comparison","text":""},{"location":"comparison/semaphore-implementation/#redlock4j_7","title":"redlock4j","text":"<p>Acquisition (N permits on M nodes): - N \u00d7 M <code>SET NX</code> operations - Sequential per permit - Parallel across nodes - Rollback on failure: N \u00d7 M <code>DELETE</code></p> <p>Release (N permits on M nodes): - N \u00d7 M <code>DELETE</code> operations - No notification overhead</p> <p>Complexity: O(N \u00d7 M) per operation</p> <p>Latency: - Higher due to quorum requirement - Multiple round trips per permit - No pub/sub overhead</p> <p>Example (3 permits, 3 nodes): <pre><code>Acquire:\n  Permit 1: SET on Node1, Node2, Node3 (parallel)\n  Permit 2: SET on Node1, Node2, Node3 (parallel)\n  Permit 3: SET on Node1, Node2, Node3 (parallel)\nTotal: 9 operations\n\nRelease:\n  DELETE permit1 on Node1, Node2, Node3\n  DELETE permit2 on Node1, Node2, Node3\n  DELETE permit3 on Node1, Node2, Node3\nTotal: 9 operations\n</code></pre></p>"},{"location":"comparison/semaphore-implementation/#redisson_6","title":"Redisson","text":"<p>Acquisition (N permits): - 1 Lua script execution (atomic) - If waiting: 1 pub/sub subscription - Notifications on release</p> <p>Release (N permits): - 1 Lua script execution - 1 <code>PUBLISH</code> to channel</p> <p>Complexity: O(1) per operation</p> <p>Latency: - Lower for single instance - Single round trip - Pub/sub notification overhead</p> <p>Example (3 permits): <pre><code>Acquire:\n  1 Lua script: GET + DECRBY\n  If blocked: subscribe to channel\nTotal: 1-2 operations\n\nRelease:\n  1 Lua script: INCRBY + PUBLISH\nTotal: 1 operation\n</code></pre></p>"},{"location":"comparison/semaphore-implementation/#safety-correctness","title":"Safety &amp; Correctness","text":""},{"location":"comparison/semaphore-implementation/#redlock4j_8","title":"redlock4j","text":"<p>Safety Guarantees: - \u2705 Quorum-based consistency - \u2705 Survives minority node failures - \u2705 Clock drift compensation - \u2705 Automatic permit expiration - \u2705 No single point of failure</p> <p>Potential Issues: - \u26a0\ufe0f Higher latency - \u26a0\ufe0f More network overhead - \u26a0\ufe0f <code>availablePermits()</code> not accurate - \u26a0\ufe0f No permit counting mechanism - \u26a0\ufe0f Polling-based (no notifications)</p> <p>Consistency Model: <pre><code>Permit acquired if:\n  - Quorum of nodes have the permit key\n  - Validity time &gt; 0\n  - No clock drift issues\n</code></pre></p>"},{"location":"comparison/semaphore-implementation/#redisson_7","title":"Redisson","text":"<p>Safety Guarantees: - \u2705 Atomic operations (Lua scripts) - \u2705 Accurate permit counting - \u2705 Efficient pub/sub notifications - \u2705 Async/reactive support - \u2705 Low latency</p> <p>Potential Issues: - \u26a0\ufe0f Single point of failure (single instance) - \u26a0\ufe0f No quorum mechanism - \u26a0\ufe0f No automatic permit expiration - \u26a0\ufe0f Permits persist indefinitely - \u26a0\ufe0f Thundering herd on notification</p> <p>Consistency Model: <pre><code>Permit acquired if:\n  - Counter &gt;= requested permits\n  - Atomic decrement succeeds\n  - No distributed consistency\n</code></pre></p>"},{"location":"comparison/semaphore-implementation/#use-case-comparison","title":"Use Case Comparison","text":""},{"location":"comparison/semaphore-implementation/#redlock4j-redlocksemaphore_1","title":"redlock4j RedlockSemaphore","text":"<p>Best For: - Distributed systems requiring quorum-based safety - Rate limiting with strong consistency - Scenarios where permit expiration is critical - Multi-master Redis setups - Fault-tolerant resource pooling</p> <p>Example Scenarios: <pre><code>// API rate limiting with fault tolerance\nRedlockSemaphore apiLimiter = new RedlockSemaphore(\n    \"api:external:rate-limit\", 100, redisDrivers, config\n);\n\n// Database connection pool with auto-expiration\nRedlockSemaphore dbPool = new RedlockSemaphore(\n    \"db:connection:pool\", 50, redisDrivers, config\n);\n\n// Distributed job throttling\nRedlockSemaphore jobThrottle = new RedlockSemaphore(\n    \"jobs:concurrent-limit\", 10, redisDrivers, config\n);\n</code></pre></p>"},{"location":"comparison/semaphore-implementation/#redisson-redissonsemaphore_1","title":"Redisson RedissonSemaphore","text":"<p>Best For: - Single Redis instance deployments - High-throughput rate limiting - Scenarios requiring accurate permit counting - Applications needing async/reactive APIs - Dynamic permit management</p> <p>Example Scenarios: <pre><code>// High-throughput API rate limiting\nRSemaphore apiLimiter = redisson.getSemaphore(\"api:rate-limit\");\napiLimiter.trySetPermits(1000);\n\n// Resource pool with dynamic sizing\nRSemaphore resourcePool = redisson.getSemaphore(\"resource:pool\");\nresourcePool.addPermits(50); // Can adjust at runtime\n\n// Async rate limiting\nRSemaphore asyncLimiter = redisson.getSemaphore(\"async:limiter\");\nasyncLimiter.trySetPermits(100);\nRFuture&lt;Boolean&gt; future = asyncLimiter.tryAcquireAsync(5, TimeUnit.SECONDS);\n</code></pre></p>"},{"location":"comparison/semaphore-implementation/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"comparison/semaphore-implementation/#redlock4j_9","title":"redlock4j","text":"<p>Code Complexity: ~370 lines</p> <p>Pros: - \u2705 Quorum-based safety - \u2705 Automatic permit expiration - \u2705 Fault-tolerant - \u2705 Clock drift compensation - \u2705 Thread-local state tracking</p> <p>Cons: - \u274c Higher latency - \u274c More Redis operations - \u274c No accurate permit counting - \u274c No permit management operations - \u274c Polling-based waiting</p>"},{"location":"comparison/semaphore-implementation/#redisson_8","title":"Redisson","text":"<p>Code Complexity: ~600 lines (with async support)</p> <p>Pros: - \u2705 Low latency - \u2705 Atomic operations - \u2705 Accurate permit counting - \u2705 Pub/sub notifications - \u2705 Async/reactive support - \u2705 Rich API (drain, add, set permits)</p> <p>Cons: - \u274c Single point of failure - \u274c No quorum mechanism - \u274c No automatic expiration - \u274c Permits persist indefinitely - \u274c More complex implementation</p>"},{"location":"comparison/semaphore-implementation/#feature-comparison-table","title":"Feature Comparison Table","text":"Feature redlock4j Redisson Data Model Individual permit keys Single counter Quorum Yes (per permit) No Fault Tolerance Survives minority failures Single point of failure Permit Expiration Automatic (TTL) Manual (optional) Permit Counting Not accurate Accurate (O(1)) Waiting Mechanism Polling Pub/sub Fairness Non-fair Non-fair Async Support No Yes Reactive Support No Yes Initialization Implicit Explicit Permit Management Limited Rich (add/drain/set) Performance O(N\u00d7M) O(1) Latency Higher Lower Network Overhead High Low Clock Drift Compensated Not applicable"},{"location":"comparison/semaphore-implementation/#recommendations","title":"Recommendations","text":""},{"location":"comparison/semaphore-implementation/#choose-redlock4j-redlocksemaphore-when","title":"Choose redlock4j RedlockSemaphore when:","text":"<ul> <li>\u2705 Need quorum-based distributed consistency</li> <li>\u2705 Require fault tolerance (multi-master)</li> <li>\u2705 Automatic permit expiration is critical</li> <li>\u2705 Can tolerate higher latency</li> <li>\u2705 Prefer simpler initialization</li> </ul>"},{"location":"comparison/semaphore-implementation/#choose-redisson-redissonsemaphore-when","title":"Choose Redisson RedissonSemaphore when:","text":"<ul> <li>\u2705 Single Redis instance is acceptable</li> <li>\u2705 Need high throughput / low latency</li> <li>\u2705 Require accurate permit counting</li> <li>\u2705 Need async/reactive APIs</li> <li>\u2705 Want dynamic permit management</li> <li>\u2705 Efficient waiting (pub/sub) is important</li> </ul>"},{"location":"comparison/semaphore-implementation/#for-fair-semaphores","title":"For Fair Semaphores:","text":"<ul> <li>Use Redisson's <code>RedissonPermitExpirableSemaphore</code> for FIFO ordering</li> <li>redlock4j doesn't currently provide fair semaphore</li> </ul>"},{"location":"comparison/semaphore-implementation/#migration-considerations","title":"Migration Considerations","text":""},{"location":"comparison/semaphore-implementation/#from-redisson-to-redlock4j","title":"From Redisson to redlock4j","text":"<pre><code>// Before (Redisson)\nRSemaphore semaphore = redisson.getSemaphore(\"api-limiter\");\nsemaphore.trySetPermits(5);\nif (semaphore.tryAcquire(5, TimeUnit.SECONDS)) {\n    try {\n        // work\n    } finally {\n        semaphore.release();\n    }\n}\n\n// After (redlock4j)\nRedlockSemaphore semaphore = new RedlockSemaphore(\n    \"api-limiter\", 5, redisDrivers, config\n);\nif (semaphore.tryAcquire(5, TimeUnit.SECONDS)) {\n    try {\n        // work\n    } finally {\n        semaphore.release();\n    }\n}\n</code></pre> <p>Benefits: - Quorum-based safety - Fault tolerance - Automatic expiration</p> <p>Considerations: - Higher latency - No accurate permit counting - No dynamic permit management</p>"},{"location":"comparison/semaphore-implementation/#from-redlock4j-to-redisson","title":"From redlock4j to Redisson","text":"<pre><code>// Before (redlock4j)\nRedlockSemaphore semaphore = new RedlockSemaphore(\n    \"api-limiter\", 5, redisDrivers, config\n);\n\n// After (Redisson)\nRSemaphore semaphore = redisson.getSemaphore(\"api-limiter\");\nsemaphore.trySetPermits(5);\n</code></pre> <p>Benefits: - Lower latency - Accurate permit counting - Async/reactive support - Dynamic permit management</p> <p>Considerations: - Single point of failure - Must initialize explicitly - No automatic expiration</p>"},{"location":"comparison/semaphore-implementation/#conclusion","title":"Conclusion","text":"<p>Both implementations serve different purposes:</p> <p>redlock4j RedlockSemaphore: - Designed for distributed consistency with quorum-based safety - Individual permit keys with automatic expiration - Higher latency but fault-tolerant - Simpler initialization, limited management - Best for multi-master setups requiring strong consistency</p> <p>Redisson RedissonSemaphore: - Designed for high-performance single-instance deployments - Atomic counter with pub/sub notifications - Lower latency but single point of failure - Rich API with dynamic permit management - Best for high-throughput scenarios with single Redis instance</p> <p>Choose based on your specific requirements: - Distributed consistency &amp; fault tolerance \u2192 redlock4j RedlockSemaphore - High throughput &amp; low latency \u2192 Redisson RedissonSemaphore - Fair ordering (FIFO) \u2192 Redisson RedissonPermitExpirableSemaphore</p> <p>Flow: 1. Generate unique permit ID for each permit 2. For each permit, try <code>SET NX</code> on all nodes 3. Check if quorum achieved for each permit 4. If any permit fails quorum, rollback all 5. Validate total acquisition time</p> <p>Redis Operations (for N permits on M nodes): - N \u00d7 M <code>SET NX</code> operations - Rollback: up to N \u00d7 M <code>DELETE</code> operations</p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#maven","title":"Maven","text":"<p>Add the following dependency to your <code>pom.xml</code>:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.codarama&lt;/groupId&gt;\n    &lt;artifactId&gt;redlock4j&lt;/artifactId&gt;\n    &lt;version&gt;1.1.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>You'll also need to add a Redis client dependency. Redlock4j supports both Jedis and Lettuce:</p>"},{"location":"getting-started/installation/#using-jedis","title":"Using Jedis","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;redis.clients&lt;/groupId&gt;\n    &lt;artifactId&gt;jedis&lt;/artifactId&gt;\n    &lt;version&gt;7.1.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"getting-started/installation/#using-lettuce","title":"Using Lettuce","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;\n    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;\n    &lt;version&gt;7.1.0.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"getting-started/installation/#gradle","title":"Gradle","text":"<p>Add the following to your <code>build.gradle</code>:</p> <pre><code>dependencies {\n    implementation 'org.codarama:redlock4j:1.1.0'\n\n    // Choose one Redis client:\n    // For Jedis:\n    implementation 'redis.clients:jedis:7.1.0'\n\n    // Or for Lettuce:\n    implementation 'io.lettuce:lettuce-core:7.1.0.RELEASE'\n}\n</code></pre>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Java 8 or higher</li> <li>Redis 2.6.12 or higher (for Lua script support)</li> <li>One of the supported Redis clients:<ul> <li>Jedis 3.0+ or 4.0+</li> <li>Lettuce 5.0+ or 6.0+</li> </ul> </li> </ul>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>After adding the dependencies, verify the installation by creating a simple test:</p> <pre><code>import org.codarama.redlock4j.Redlock;\nimport redis.clients.jedis.JedisPool;\n\npublic class RedlockTest {\n    public static void main(String[] args) {\n        JedisPool pool = new JedisPool(\"localhost\", 6379);\n        Redlock redlock = new Redlock(pool);\n        System.out.println(\"Redlock4j is ready!\");\n        pool.close();\n    }\n}\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Learn the basics</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>This guide will help you get started with Redlock4j in just a few minutes.</p>"},{"location":"getting-started/quick-start/#basic-setup","title":"Basic Setup","text":""},{"location":"getting-started/quick-start/#1-create-redis-connection-pools","title":"1. Create Redis Connection Pools","text":"<p>First, create connection pools for your Redis instances. For production use, you should have at least 3 independent Redis instances.</p> <pre><code>import redis.clients.jedis.JedisPool;\n\n// Create pools for multiple Redis instances\nJedisPool pool1 = new JedisPool(\"redis1.example.com\", 6379);\nJedisPool pool2 = new JedisPool(\"redis2.example.com\", 6379);\nJedisPool pool3 = new JedisPool(\"redis3.example.com\", 6379);\n</code></pre>"},{"location":"getting-started/quick-start/#2-create-a-redlock-instance","title":"2. Create a Redlock Instance","text":"<pre><code>import org.codarama.redlock4j.Redlock;\n\nRedlock redlock = new Redlock(pool1, pool2, pool3);\n</code></pre>"},{"location":"getting-started/quick-start/#3-acquire-and-release-locks","title":"3. Acquire and Release Locks","text":"<pre><code>import org.codarama.redlock4j.Lock;\n\n// Try to acquire a lock for \"my-resource\" with 10 second TTL\nLock lock = redlock.lock(\"my-resource\", 10000);\n\nif (lock != null) {\n    try {\n        // Lock acquired successfully\n        // Perform your critical section here\n        System.out.println(\"Lock acquired! Performing critical operation...\");\n        performCriticalOperation();\n    } finally {\n        // Always release the lock\n        redlock.unlock(lock);\n        System.out.println(\"Lock released\");\n    }\n} else {\n    // Failed to acquire lock\n    System.out.println(\"Could not acquire lock\");\n}\n</code></pre>"},{"location":"getting-started/quick-start/#complete-example","title":"Complete Example","text":"<p>Here's a complete working example:</p> <pre><code>import org.codarama.redlock4j.Redlock;\nimport org.codarama.redlock4j.Lock;\nimport redis.clients.jedis.JedisPool;\n\npublic class RedlockExample {\n    public static void main(String[] args) {\n        // Setup Redis pools\n        JedisPool pool1 = new JedisPool(\"localhost\", 6379);\n        JedisPool pool2 = new JedisPool(\"localhost\", 6380);\n        JedisPool pool3 = new JedisPool(\"localhost\", 6381);\n\n        // Create Redlock instance\n        Redlock redlock = new Redlock(pool1, pool2, pool3);\n\n        // Resource identifier\n        String resourceId = \"shared-resource\";\n\n        // Lock TTL in milliseconds (10 seconds)\n        int ttl = 10000;\n\n        // Try to acquire lock\n        Lock lock = redlock.lock(resourceId, ttl);\n\n        if (lock != null) {\n            try {\n                // Critical section\n                System.out.println(\"Processing shared resource...\");\n                Thread.sleep(2000); // Simulate work\n                System.out.println(\"Done processing\");\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            } finally {\n                // Release lock\n                redlock.unlock(lock);\n            }\n        } else {\n            System.out.println(\"Another process is using the resource\");\n        }\n\n        // Cleanup\n        pool1.close();\n        pool2.close();\n        pool3.close();\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#using-lettuce-instead-of-jedis","title":"Using Lettuce Instead of Jedis","text":"<p>If you prefer Lettuce over Jedis:</p> <pre><code>import io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport org.codarama.redlock4j.Redlock;\n\n// Create Lettuce clients\nRedisClient client1 = RedisClient.create(\"redis://localhost:6379\");\nRedisClient client2 = RedisClient.create(\"redis://localhost:6380\");\nRedisClient client3 = RedisClient.create(\"redis://localhost:6381\");\n\n// Create Redlock instance\nRedlock redlock = new Redlock(client1, client2, client3);\n\n// Use the same lock/unlock pattern as above\n</code></pre>"},{"location":"getting-started/quick-start/#important-notes","title":"Important Notes","text":"<p>Lock TTL</p> <p>Always set a TTL that's longer than your critical section execution time. If the lock expires while you're still processing, another client might acquire the lock.</p> <p>Always Unlock</p> <p>Always release locks in a <code>finally</code> block to ensure they're released even if an exception occurs.</p> <p>Minimum Redis Instances</p> <p>For production use, always use at least 3 independent Redis instances to ensure proper fault tolerance.</p>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Basic Usage - Explore more usage patterns</li> <li>Advanced Locking - Learn about advanced features</li> </ul>"},{"location":"guide/advanced-locking/","title":"Advanced Locking","text":"<p>Redlock4j provides advanced distributed synchronization primitives beyond basic locks.</p>"},{"location":"guide/advanced-locking/#fair-lock","title":"Fair Lock","text":"<p>Fair locks ensure FIFO ordering for lock acquisition, preventing thread starvation.</p>"},{"location":"guide/advanced-locking/#usage","title":"Usage","text":"<pre><code>Lock fairLock = redlockManager.createFairLock(\"fair-resource\");\n\nfairLock.lock();\ntry {\n    // Critical section - guaranteed FIFO ordering\n    performWork();\n} finally {\n    fairLock.unlock();\n}\n</code></pre>"},{"location":"guide/advanced-locking/#use-cases","title":"Use Cases","text":"<ul> <li>High-contention scenarios requiring fairness</li> <li>Preventing thread starvation</li> <li>Maintaining request ordering in distributed systems</li> </ul>"},{"location":"guide/advanced-locking/#multi-lock","title":"Multi-Lock","text":"<p>Atomic acquisition of multiple resources simultaneously, preventing deadlocks.</p>"},{"location":"guide/advanced-locking/#usage_1","title":"Usage","text":"<pre><code>MultiLock multiLock = redlockManager.createMultiLock(\"resource-1\", \"resource-2\", \"resource-3\");\n\nmultiLock.lock();\ntry {\n    // All resources locked atomically\n    processMultipleResources();\n} finally {\n    multiLock.unlock();\n}\n</code></pre>"},{"location":"guide/advanced-locking/#use-cases_1","title":"Use Cases","text":"<ul> <li>Database transactions across multiple tables</li> <li>Coordinating access to multiple shared resources</li> <li>Preventing circular wait deadlocks</li> </ul>"},{"location":"guide/advanced-locking/#read-write-lock","title":"Read-Write Lock","text":"<p>Separate read and write locks for improved concurrency.</p>"},{"location":"guide/advanced-locking/#usage_2","title":"Usage","text":"<pre><code>ReadWriteLock rwLock = redlockManager.createReadWriteLock(\"shared-data\");\n\n// Multiple readers can acquire simultaneously\nrwLock.readLock().lock();\ntry {\n    // Read operation\n    data = readData();\n} finally {\n    rwLock.readLock().unlock();\n}\n\n// Writers get exclusive access\nrwLock.writeLock().lock();\ntry {\n    // Write operation\n    writeData(newData);\n} finally {\n    rwLock.writeLock().unlock();\n}\n</code></pre>"},{"location":"guide/advanced-locking/#use-cases_2","title":"Use Cases","text":"<ul> <li>Read-heavy workloads</li> <li>Caching scenarios</li> <li>Shared configuration data</li> </ul>"},{"location":"guide/advanced-locking/#distributed-semaphore","title":"Distributed Semaphore","text":"<p>Control access to a limited number of resources.</p>"},{"location":"guide/advanced-locking/#usage_3","title":"Usage","text":"<pre><code>Semaphore semaphore = redlockManager.createSemaphore(\"resource-pool\", 5); // 5 permits\n\nsemaphore.acquire();\ntry {\n    // Use limited resource\n    useResource();\n} finally {\n    semaphore.release();\n}\n</code></pre>"},{"location":"guide/advanced-locking/#use-cases_3","title":"Use Cases","text":"<ul> <li>Connection pool management</li> <li>Rate limiting</li> <li>Resource quota enforcement</li> </ul>"},{"location":"guide/advanced-locking/#countdownlatch","title":"CountDownLatch","text":"<p>Coordinate multiple distributed processes.</p>"},{"location":"guide/advanced-locking/#usage_4","title":"Usage","text":"<pre><code>CountDownLatch latch = redlockManager.createCountDownLatch(\"startup-latch\", 3);\n\n// Worker threads\nlatch.countDown();\n\n// Coordinator thread\nlatch.await(); // Waits until count reaches 0\n</code></pre>"},{"location":"guide/advanced-locking/#use-cases_4","title":"Use Cases","text":"<ul> <li>Distributed initialization</li> <li>Barrier synchronization</li> <li>Coordinating parallel tasks</li> </ul>"},{"location":"guide/advanced-locking/#best-practices","title":"Best Practices","text":""},{"location":"guide/advanced-locking/#choose-the-right-primitive","title":"Choose the Right Primitive","text":"<ul> <li>Basic Lock: Simple mutual exclusion</li> <li>Fair Lock: When ordering matters</li> <li>Multi-Lock: Multiple resources needed atomically</li> <li>Read-Write Lock: Read-heavy workloads</li> <li>Semaphore: Limited resource pool</li> <li>CountDownLatch: Coordination between processes</li> </ul>"},{"location":"guide/advanced-locking/#timeout-configuration","title":"Timeout Configuration","text":"<p>Always use timeouts to prevent indefinite blocking:</p> <pre><code>boolean acquired = lock.tryLock(5, TimeUnit.SECONDS);\nif (acquired) {\n    try {\n        // Critical section\n    } finally {\n        lock.unlock();\n    }\n} else {\n    // Handle timeout\n}\n</code></pre>"},{"location":"guide/advanced-locking/#error-handling","title":"Error Handling","text":"<p>Properly handle failures:</p> <pre><code>Lock lock = null;\ntry {\n    lock = redlockManager.createLock(\"resource\");\n    lock.lock();\n    // Critical section\n} catch (Exception e) {\n    logger.error(\"Error in critical section\", e);\n} finally {\n    if (lock != null) {\n        try {\n            lock.unlock();\n        } catch (Exception e) {\n            logger.error(\"Error releasing lock\", e);\n        }\n    }\n}\n</code></pre>"},{"location":"guide/advanced-locking/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Fair locks have higher overhead than regular locks</li> <li>Multi-locks require more Redis operations</li> <li>Read-write locks optimize for read-heavy scenarios</li> <li>Semaphores scale with permit count</li> </ul>"},{"location":"guide/advanced-locking/#next-steps","title":"Next Steps","text":"<ul> <li>Best Practices - Follow recommended practices</li> <li>API Reference - Detailed API documentation</li> </ul> <p>For complete details, see ADVANCED_LOCKING.md in the repository.</p>"},{"location":"guide/basic-usage/","title":"Basic Usage","text":"<p>This guide covers common usage patterns and scenarios for Redlock4j.</p>"},{"location":"guide/basic-usage/#simple-lock-pattern","title":"Simple Lock Pattern","text":"<p>The most basic usage pattern:</p> <pre><code>Lock lock = redlock.lock(\"resource-id\", 10000);\nif (lock != null) {\n    try {\n        // Critical section\n    } finally {\n        redlock.unlock(lock);\n    }\n}\n</code></pre>"},{"location":"guide/basic-usage/#try-lock-pattern","title":"Try-Lock Pattern","text":"<p>Attempt to acquire a lock without retries:</p> <pre><code>Lock lock = redlock.tryLock(\"resource-id\", 10000);\nif (lock != null) {\n    try {\n        // Got the lock immediately\n    } finally {\n        redlock.unlock(lock);\n    }\n} else {\n    // Lock not available, handle accordingly\n}\n</code></pre>"},{"location":"guide/basic-usage/#lock-with-timeout","title":"Lock with Timeout","text":"<p>Wait for a lock with a timeout:</p> <pre><code>Lock lock = redlock.lock(\"resource-id\", 10000, 5000); // 5 second timeout\nif (lock != null) {\n    try {\n        // Acquired lock within timeout\n    } finally {\n        redlock.unlock(lock);\n    }\n} else {\n    // Timeout expired\n}\n</code></pre>"},{"location":"guide/basic-usage/#extending-lock-duration","title":"Extending Lock Duration","text":"<p>If your operation takes longer than expected, you can extend the lock:</p> <pre><code>Lock lock = redlock.lock(\"resource-id\", 10000);\nif (lock != null) {\n    try {\n        // Do some work\n        performPartialWork();\n\n        // Need more time, extend the lock\n        boolean extended = redlock.extend(lock, 10000);\n        if (extended) {\n            // Continue working\n            performMoreWork();\n        }\n    } finally {\n        redlock.unlock(lock);\n    }\n}\n</code></pre>"},{"location":"guide/basic-usage/#checking-lock-validity","title":"Checking Lock Validity","text":"<p>Check if a lock is still valid:</p> <pre><code>Lock lock = redlock.lock(\"resource-id\", 10000);\nif (lock != null) {\n    try {\n        performWork();\n\n        if (redlock.isValid(lock)) {\n            // Lock is still valid\n            performMoreWork();\n        } else {\n            // Lock expired or was released\n            handleExpiredLock();\n        }\n    } finally {\n        redlock.unlock(lock);\n    }\n}\n</code></pre>"},{"location":"guide/basic-usage/#multiple-resources","title":"Multiple Resources","text":"<p>Lock multiple resources atomically:</p> <pre><code>String[] resources = {\"resource-1\", \"resource-2\", \"resource-3\"};\nLock lock = redlock.lock(resources, 10000);\n\nif (lock != null) {\n    try {\n        // All resources are locked\n        processMultipleResources();\n    } finally {\n        redlock.unlock(lock);\n    }\n}\n</code></pre>"},{"location":"guide/basic-usage/#reentrant-locks","title":"Reentrant Locks","text":"<p>Redlock4j supports reentrant locks (same thread can acquire the same lock multiple times):</p> <pre><code>Lock lock1 = redlock.lock(\"resource-id\", 10000);\nif (lock1 != null) {\n    try {\n        // First acquisition\n\n        Lock lock2 = redlock.lock(\"resource-id\", 10000);\n        if (lock2 != null) {\n            try {\n                // Second acquisition by same thread\n            } finally {\n                redlock.unlock(lock2);\n            }\n        }\n    } finally {\n        redlock.unlock(lock1);\n    }\n}\n</code></pre>"},{"location":"guide/basic-usage/#error-handling","title":"Error Handling","text":"<p>Proper error handling is crucial:</p> <pre><code>Lock lock = null;\ntry {\n    lock = redlock.lock(\"resource-id\", 10000);\n    if (lock != null) {\n        // Critical section\n        performCriticalOperation();\n    } else {\n        // Failed to acquire lock\n        logger.warn(\"Could not acquire lock for resource-id\");\n        handleLockFailure();\n    }\n} catch (Exception e) {\n    logger.error(\"Error during critical section\", e);\n    handleError(e);\n} finally {\n    if (lock != null) {\n        try {\n            redlock.unlock(lock);\n        } catch (Exception e) {\n            logger.error(\"Error releasing lock\", e);\n        }\n    }\n}\n</code></pre>"},{"location":"guide/basic-usage/#using-with-try-with-resources","title":"Using with Try-With-Resources","text":"<p>If your Lock implementation supports AutoCloseable:</p> <pre><code>try (Lock lock = redlock.lock(\"resource-id\", 10000)) {\n    if (lock != null) {\n        // Critical section\n        performCriticalOperation();\n    }\n} // Lock automatically released\n</code></pre>"},{"location":"guide/basic-usage/#common-patterns","title":"Common Patterns","text":""},{"location":"guide/basic-usage/#singleton-task-execution","title":"Singleton Task Execution","text":"<p>Ensure only one instance executes a task:</p> <pre><code>public void executeScheduledTask() {\n    Lock lock = redlock.lock(\"scheduled-task-id\", 60000);\n    if (lock != null) {\n        try {\n            // Only one instance will execute this\n            performScheduledTask();\n        } finally {\n            redlock.unlock(lock);\n        }\n    } else {\n        // Another instance is already executing\n        logger.info(\"Task already running on another instance\");\n    }\n}\n</code></pre>"},{"location":"guide/basic-usage/#resource-pool-management","title":"Resource Pool Management","text":"<p>Manage access to a limited resource pool:</p> <pre><code>public void processWithResource(String resourceId) {\n    Lock lock = redlock.lock(\"resource-pool:\" + resourceId, 30000);\n    if (lock != null) {\n        try {\n            Resource resource = acquireResource(resourceId);\n            processResource(resource);\n        } finally {\n            redlock.unlock(lock);\n        }\n    }\n}\n</code></pre>"},{"location":"guide/basic-usage/#next-steps","title":"Next Steps","text":"<ul> <li>Advanced Locking - Learn about advanced features</li> <li>Best Practices - Follow recommended practices</li> </ul>"},{"location":"guide/best-practices/","title":"Best Practices","text":"<p>Follow these best practices to use Redlock4j effectively and safely in production.</p>"},{"location":"guide/best-practices/#lock-management","title":"Lock Management","text":""},{"location":"guide/best-practices/#always-release-locks","title":"Always Release Locks","text":"<p>Always release locks in a <code>finally</code> block:</p> <pre><code>Lock lock = redlock.lock(\"resource\", 10000);\nif (lock != null) {\n    try {\n        // Critical section\n    } finally {\n        redlock.unlock(lock);  // Always execute\n    }\n}\n</code></pre>"},{"location":"guide/best-practices/#check-lock-acquisition","title":"Check Lock Acquisition","text":"<p>Always check if lock acquisition succeeded:</p> <pre><code>Lock lock = redlock.lock(\"resource\", 10000);\nif (lock != null) {\n    // Lock acquired successfully\n} else {\n    // Failed to acquire lock - handle appropriately\n    handleLockFailure();\n}\n</code></pre>"},{"location":"guide/best-practices/#use-appropriate-ttl","title":"Use Appropriate TTL","text":"<p>Set TTL longer than your operation:</p> <pre><code>// Bad: TTL too short\nLock lock = redlock.lock(\"resource\", 1000);  // 1 second\nperformLongOperation();  // Takes 5 seconds - lock will expire!\n\n// Good: TTL with safety margin\nLock lock = redlock.lock(\"resource\", 10000);  // 10 seconds\nperformLongOperation();  // Takes 5 seconds - safe\n</code></pre>"},{"location":"guide/best-practices/#redis-configuration","title":"Redis Configuration","text":""},{"location":"guide/best-practices/#use-independent-redis-instances","title":"Use Independent Redis Instances","text":"<p>For production, use truly independent Redis instances:</p> <pre><code>// Good: Independent instances on different servers\nRedlock redlock = new Redlock(\n    new JedisPool(\"redis1.example.com\", 6379),\n    new JedisPool(\"redis2.example.com\", 6379),\n    new JedisPool(\"redis3.example.com\", 6379)\n);\n\n// Bad: Master-slave replication (not independent)\n// Don't use master and its slaves as separate instances\n</code></pre>"},{"location":"guide/best-practices/#minimum-3-instances","title":"Minimum 3 Instances","text":"<p>Always use at least 3 Redis instances:</p> <pre><code>// Minimum for fault tolerance\nRedlock redlock = new Redlock(pool1, pool2, pool3);\n\n// Better: 5 instances for higher availability\nRedlock redlock = new Redlock(pool1, pool2, pool3, pool4, pool5);\n</code></pre>"},{"location":"guide/best-practices/#use-odd-numbers","title":"Use Odd Numbers","text":"<p>Always use an odd number of instances:</p> <ul> <li>\u2705 3, 5, 7 instances</li> <li>\u274c 2, 4, 6 instances</li> </ul>"},{"location":"guide/best-practices/#error-handling","title":"Error Handling","text":""},{"location":"guide/best-practices/#handle-lock-failures","title":"Handle Lock Failures","text":"<pre><code>Lock lock = redlock.lock(\"resource\", 10000);\nif (lock == null) {\n    // Log the failure\n    logger.warn(\"Failed to acquire lock for resource\");\n\n    // Implement fallback strategy\n    // Option 1: Retry later\n    scheduleRetry();\n\n    // Option 2: Return error to caller\n    throw new LockAcquisitionException(\"Could not acquire lock\");\n\n    // Option 3: Use alternative approach\n    performAlternativeOperation();\n}\n</code></pre>"},{"location":"guide/best-practices/#handle-exceptions","title":"Handle Exceptions","text":"<pre><code>Lock lock = null;\ntry {\n    lock = redlock.lock(\"resource\", 10000);\n    if (lock != null) {\n        performCriticalOperation();\n    }\n} catch (Exception e) {\n    logger.error(\"Error in critical section\", e);\n    handleError(e);\n} finally {\n    if (lock != null) {\n        try {\n            redlock.unlock(lock);\n        } catch (Exception e) {\n            logger.error(\"Error releasing lock\", e);\n            // Don't throw - we're in finally block\n        }\n    }\n}\n</code></pre>"},{"location":"guide/best-practices/#performance","title":"Performance","text":""},{"location":"guide/best-practices/#reuse-redlock-instances","title":"Reuse Redlock Instances","text":"<p>Create Redlock instances once and reuse:</p> <pre><code>// Good: Singleton pattern\npublic class LockService {\n    private static final Redlock REDLOCK = createRedlock();\n\n    public Lock acquireLock(String resource) {\n        return REDLOCK.lock(resource, 10000);\n    }\n}\n\n// Bad: Creating new instance each time\npublic Lock acquireLock(String resource) {\n    Redlock redlock = new Redlock(pool1, pool2, pool3);  // Wasteful!\n    return redlock.lock(resource, 10000);\n}\n</code></pre>"},{"location":"guide/best-practices/#configure-connection-pools","title":"Configure Connection Pools","text":"<p>Properly configure connection pools:</p> <pre><code>JedisPoolConfig config = new JedisPoolConfig();\nconfig.setMaxTotal(128);        // Enough for your load\nconfig.setMaxIdle(64);          // Keep some idle connections\nconfig.setMinIdle(16);          // Minimum ready connections\nconfig.setTestOnBorrow(true);   // Validate connections\nconfig.setTestWhileIdle(true);  // Clean up stale connections\n</code></pre>"},{"location":"guide/best-practices/#use-appropriate-retry-settings","title":"Use Appropriate Retry Settings","text":"<pre><code>RedlockConfiguration config = RedlockConfiguration.builder()\n    .retryCount(3)      // Don't retry too many times\n    .retryDelay(200)    // Reasonable delay between retries\n    .build();\n</code></pre>"},{"location":"guide/best-practices/#resource-naming","title":"Resource Naming","text":""},{"location":"guide/best-practices/#use-descriptive-names","title":"Use Descriptive Names","text":"<pre><code>// Good: Clear and descriptive\nLock lock = redlock.lock(\"user:123:profile:update\", 10000);\nLock lock = redlock.lock(\"order:456:payment:process\", 10000);\n\n// Bad: Unclear names\nLock lock = redlock.lock(\"lock1\", 10000);\nLock lock = redlock.lock(\"temp\", 10000);\n</code></pre>"},{"location":"guide/best-practices/#use-consistent-naming-convention","title":"Use Consistent Naming Convention","text":"<pre><code>// Establish a pattern\nString lockKey = String.format(\"%s:%s:%s\", \n    entityType,    // \"user\", \"order\", \"product\"\n    entityId,      // \"123\", \"456\"\n    operation      // \"update\", \"delete\", \"process\"\n);\n</code></pre>"},{"location":"guide/best-practices/#monitoring-and-logging","title":"Monitoring and Logging","text":""},{"location":"guide/best-practices/#log-lock-operations","title":"Log Lock Operations","text":"<pre><code>Lock lock = redlock.lock(resourceId, ttl);\nif (lock != null) {\n    logger.info(\"Acquired lock for resource: {}\", resourceId);\n    try {\n        performOperation();\n    } finally {\n        redlock.unlock(lock);\n        logger.info(\"Released lock for resource: {}\", resourceId);\n    }\n} else {\n    logger.warn(\"Failed to acquire lock for resource: {}\", resourceId);\n}\n</code></pre>"},{"location":"guide/best-practices/#monitor-lock-metrics","title":"Monitor Lock Metrics","text":"<p>Track important metrics:</p> <ul> <li>Lock acquisition success rate</li> <li>Lock acquisition latency</li> <li>Lock hold time</li> <li>Lock contention rate</li> </ul>"},{"location":"guide/best-practices/#testing","title":"Testing","text":""},{"location":"guide/best-practices/#test-lock-behavior","title":"Test Lock Behavior","text":"<pre><code>@Test\npublic void testLockAcquisition() {\n    Lock lock = redlock.lock(\"test-resource\", 10000);\n    assertNotNull(lock, \"Should acquire lock\");\n\n    // Try to acquire same lock - should fail\n    Lock lock2 = redlock.tryLock(\"test-resource\", 10000);\n    assertNull(lock2, \"Should not acquire already locked resource\");\n\n    redlock.unlock(lock);\n}\n</code></pre>"},{"location":"guide/best-practices/#use-testcontainers","title":"Use Testcontainers","text":"<p>For integration tests:</p> <pre><code>@Testcontainers\npublic class RedlockIntegrationTest {\n    @Container\n    private static GenericContainer&lt;?&gt; redis = \n        new GenericContainer&lt;&gt;(\"redis:7-alpine\")\n            .withExposedPorts(6379);\n\n    @Test\n    public void testWithRealRedis() {\n        JedisPool pool = new JedisPool(\n            redis.getHost(), \n            redis.getFirstMappedPort()\n        );\n        Redlock redlock = new Redlock(pool);\n        // Test with real Redis\n    }\n}\n</code></pre>"},{"location":"guide/best-practices/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"guide/best-practices/#dont-forget-to-unlock","title":"\u274c Don't Forget to Unlock","text":"<pre><code>// Bad: No unlock\nLock lock = redlock.lock(\"resource\", 10000);\nperformOperation();  // If this throws, lock is never released!\n</code></pre>"},{"location":"guide/best-practices/#dont-use-same-redis-instance-multiple-times","title":"\u274c Don't Use Same Redis Instance Multiple Times","text":"<pre><code>// Bad: Same instance counted 3 times\nRedlock redlock = new Redlock(pool, pool, pool);  // Wrong!\n</code></pre>"},{"location":"guide/best-practices/#dont-ignore-lock-acquisition-failures","title":"\u274c Don't Ignore Lock Acquisition Failures","text":"<pre><code>// Bad: Assuming lock is always acquired\nLock lock = redlock.lock(\"resource\", 10000);\nperformOperation();  // What if lock is null?\n</code></pre>"},{"location":"guide/best-practices/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Detailed API documentation</li> <li>Advanced Locking - Advanced features</li> </ul>"},{"location":"guide/redis-clients/","title":"Redis Clients","text":"<p>Redlock4j supports both Jedis and Lettuce Redis clients through a clean driver abstraction.</p>"},{"location":"guide/redis-clients/#jedis","title":"Jedis","text":"<p>Jedis is a synchronous Redis client that's simple and straightforward.</p>"},{"location":"guide/redis-clients/#setup","title":"Setup","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;redis.clients&lt;/groupId&gt;\n    &lt;artifactId&gt;jedis&lt;/artifactId&gt;\n    &lt;version&gt;7.1.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"guide/redis-clients/#basic-usage","title":"Basic Usage","text":"<pre><code>import redis.clients.jedis.JedisPool;\nimport org.codarama.redlock4j.Redlock;\n\nJedisPool pool1 = new JedisPool(\"localhost\", 6379);\nJedisPool pool2 = new JedisPool(\"localhost\", 6380);\nJedisPool pool3 = new JedisPool(\"localhost\", 6381);\n\nRedlock redlock = new Redlock(pool1, pool2, pool3);\n</code></pre>"},{"location":"guide/redis-clients/#connection-pool-configuration","title":"Connection Pool Configuration","text":"<pre><code>import redis.clients.jedis.JedisPoolConfig;\n\nJedisPoolConfig config = new JedisPoolConfig();\nconfig.setMaxTotal(128);\nconfig.setMaxIdle(128);\nconfig.setMinIdle(16);\nconfig.setTestOnBorrow(true);\nconfig.setTestOnReturn(true);\nconfig.setTestWhileIdle(true);\nconfig.setMinEvictableIdleTimeMillis(60000);\nconfig.setTimeBetweenEvictionRunsMillis(30000);\nconfig.setNumTestsPerEvictionRun(3);\nconfig.setBlockWhenExhausted(true);\n\nJedisPool pool = new JedisPool(config, \"localhost\", 6379, 2000);\n</code></pre>"},{"location":"guide/redis-clients/#advantages","title":"Advantages","text":"<ul> <li>Simple and easy to use</li> <li>Synchronous API is straightforward</li> <li>Lower memory footprint</li> <li>Good for simple use cases</li> </ul>"},{"location":"guide/redis-clients/#disadvantages","title":"Disadvantages","text":"<ul> <li>Blocking I/O</li> <li>Less efficient for high-throughput scenarios</li> <li>No built-in async support</li> </ul>"},{"location":"guide/redis-clients/#lettuce","title":"Lettuce","text":"<p>Lettuce is an advanced Redis client with async and reactive support.</p>"},{"location":"guide/redis-clients/#setup_1","title":"Setup","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;\n    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;\n    &lt;version&gt;7.1.0.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"guide/redis-clients/#basic-usage_1","title":"Basic Usage","text":"<pre><code>import io.lettuce.core.RedisClient;\nimport org.codarama.redlock4j.Redlock;\n\nRedisClient client1 = RedisClient.create(\"redis://localhost:6379\");\nRedisClient client2 = RedisClient.create(\"redis://localhost:6380\");\nRedisClient client3 = RedisClient.create(\"redis://localhost:6381\");\n\nRedlock redlock = new Redlock(client1, client2, client3);\n</code></pre>"},{"location":"guide/redis-clients/#advanced-configuration","title":"Advanced Configuration","text":"<pre><code>import io.lettuce.core.RedisURI;\nimport io.lettuce.core.ClientOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport io.lettuce.core.resource.ClientResources;\nimport io.lettuce.core.resource.DefaultClientResources;\nimport java.time.Duration;\n\n// Configure client resources\nClientResources resources = DefaultClientResources.builder()\n    .ioThreadPoolSize(4)\n    .computationThreadPoolSize(4)\n    .build();\n\n// Configure Redis URI\nRedisURI redisUri = RedisURI.builder()\n    .withHost(\"localhost\")\n    .withPort(6379)\n    .withTimeout(Duration.ofSeconds(5))\n    .withDatabase(0)\n    .build();\n\n// Configure client options\nClientOptions options = ClientOptions.builder()\n    .autoReconnect(true)\n    .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(5)))\n    .build();\n\nRedisClient client = RedisClient.create(resources, redisUri);\nclient.setOptions(options);\n</code></pre>"},{"location":"guide/redis-clients/#advantages_1","title":"Advantages","text":"<ul> <li>Non-blocking I/O with Netty</li> <li>Async and reactive API support</li> <li>Better performance for high-throughput</li> <li>Advanced features (clustering, sentinel)</li> </ul>"},{"location":"guide/redis-clients/#disadvantages_1","title":"Disadvantages","text":"<ul> <li>More complex API</li> <li>Higher memory footprint</li> <li>Steeper learning curve</li> </ul>"},{"location":"guide/redis-clients/#choosing-between-jedis-and-lettuce","title":"Choosing Between Jedis and Lettuce","text":""},{"location":"guide/redis-clients/#use-jedis-when","title":"Use Jedis When:","text":"<ul> <li>You need a simple, straightforward API</li> <li>Your application is primarily synchronous</li> <li>You have moderate throughput requirements</li> <li>You want minimal dependencies</li> </ul>"},{"location":"guide/redis-clients/#use-lettuce-when","title":"Use Lettuce When:","text":"<ul> <li>You need high throughput</li> <li>You want async/reactive programming</li> <li>You're using Redis Cluster or Sentinel</li> <li>You need advanced features</li> </ul>"},{"location":"guide/redis-clients/#mixed-usage","title":"Mixed Usage","text":"<p>You can use different clients for different Redis instances:</p> <pre><code>// Mix Jedis and Lettuce (not recommended, but possible)\nJedisPool jedisPool = new JedisPool(\"localhost\", 6379);\nRedisClient lettuceClient1 = RedisClient.create(\"redis://localhost:6380\");\nRedisClient lettuceClient2 = RedisClient.create(\"redis://localhost:6381\");\n\n// This works, but stick to one client type for consistency\nRedlock redlock = new Redlock(jedisPool, lettuceClient1, lettuceClient2);\n</code></pre> <p>Consistency Recommendation</p> <p>While mixing clients is technically possible, it's recommended to use the same client type for all Redis instances for consistency and easier maintenance.</p>"},{"location":"guide/redis-clients/#connection-management","title":"Connection Management","text":""},{"location":"guide/redis-clients/#jedis_1","title":"Jedis","text":"<pre><code>// Always close pools when done\ntry {\n    // Use redlock\n} finally {\n    pool1.close();\n    pool2.close();\n    pool3.close();\n}\n</code></pre>"},{"location":"guide/redis-clients/#lettuce_1","title":"Lettuce","text":"<pre><code>// Shutdown clients and resources\ntry {\n    // Use redlock\n} finally {\n    client1.shutdown();\n    client2.shutdown();\n    client3.shutdown();\n    resources.shutdown();\n}\n</code></pre>"},{"location":"guide/redis-clients/#next-steps","title":"Next Steps","text":"<ul> <li>Best Practices - Follow recommended practices</li> <li>Configuration - Detailed configuration options</li> </ul>"}]}